// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: admin.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const getAdminSummary = `-- name: GetAdminSummary :one
SELECT
  (SELECT COUNT(*) FROM nguoi_dung)                             AS total_users,
  (SELECT COUNT(*) FROM nguoi_dung WHERE dang_hoat_dong = TRUE) AS active_users,
  (SELECT COUNT(*) FROM tour)                                   AS total_tours,
  (SELECT COUNT(*) FROM tour WHERE dang_hoat_dong = TRUE)       AS active_tours,
  (SELECT COUNT(*) FROM dat_cho_tour)                           AS total_bookings,
  COALESCE((SELECT SUM(so_tien) FROM thanh_toan WHERE trang_thai = 'thanh_cong'), 0) AS total_revenue,
  COALESCE((SELECT AVG(rating)::float FROM danh_gia), 0)        AS avg_rating
`

type GetAdminSummaryRow struct {
	TotalUsers    int64       `json:"total_users"`
	ActiveUsers   int64       `json:"active_users"`
	TotalTours    int64       `json:"total_tours"`
	ActiveTours   int64       `json:"active_tours"`
	TotalBookings int64       `json:"total_bookings"`
	TotalRevenue  interface{} `json:"total_revenue"`
	AvgRating     interface{} `json:"avg_rating"`
}

func (q *Queries) GetAdminSummary(ctx context.Context) (GetAdminSummaryRow, error) {
	row := q.db.QueryRow(ctx, getAdminSummary)
	var i GetAdminSummaryRow
	err := row.Scan(
		&i.TotalUsers,
		&i.ActiveUsers,
		&i.TotalTours,
		&i.ActiveTours,
		&i.TotalBookings,
		&i.TotalRevenue,
		&i.AvgRating,
	)
	return i, err
}

const getBookingsByMonth = `-- name: GetBookingsByMonth :many
SELECT
  EXTRACT(MONTH FROM ngay_dat)::int AS month,
  COUNT(*)::int                     AS total_bookings
FROM dat_cho_tour
WHERE EXTRACT(YEAR FROM ngay_dat) = $1::int
GROUP BY month
ORDER BY month
`

type GetBookingsByMonthRow struct {
	Month         int32 `json:"month"`
	TotalBookings int32 `json:"total_bookings"`
}

func (q *Queries) GetBookingsByMonth(ctx context.Context, year int32) ([]GetBookingsByMonthRow, error) {
	rows, err := q.db.Query(ctx, getBookingsByMonth, year)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetBookingsByMonthRow
	for rows.Next() {
		var i GetBookingsByMonthRow
		if err := rows.Scan(&i.Month, &i.TotalBookings); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getBookingsByStatus = `-- name: GetBookingsByStatus :many
SELECT
  trang_thai::text AS status,
  COUNT(*)::int    AS total
FROM dat_cho_tour
GROUP BY status
ORDER BY total DESC
`

type GetBookingsByStatusRow struct {
	Status string `json:"status"`
	Total  int32  `json:"total"`
}

func (q *Queries) GetBookingsByStatus(ctx context.Context) ([]GetBookingsByStatusRow, error) {
	rows, err := q.db.Query(ctx, getBookingsByStatus)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetBookingsByStatusRow
	for rows.Next() {
		var i GetBookingsByStatusRow
		if err := rows.Scan(&i.Status, &i.Total); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getNewUsersByMonth = `-- name: GetNewUsersByMonth :many
SELECT
  EXTRACT(MONTH FROM ngay_tao)::int AS month,
  COUNT(*)::int                     AS new_users
FROM nguoi_dung
WHERE EXTRACT(YEAR FROM ngay_tao) = $1::int
GROUP BY month
ORDER BY month
`

type GetNewUsersByMonthRow struct {
	Month    int32 `json:"month"`
	NewUsers int32 `json:"new_users"`
}

func (q *Queries) GetNewUsersByMonth(ctx context.Context, year int32) ([]GetNewUsersByMonthRow, error) {
	rows, err := q.db.Query(ctx, getNewUsersByMonth, year)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetNewUsersByMonthRow
	for rows.Next() {
		var i GetNewUsersByMonthRow
		if err := rows.Scan(&i.Month, &i.NewUsers); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRevenueByDateRange = `-- name: GetRevenueByDateRange :one
SELECT
  COALESCE(SUM(so_tien), 0) AS total_revenue,
  COUNT(*)::int             AS total_transactions
FROM thanh_toan
WHERE ngay_thanh_toan >= $1
  AND ngay_thanh_toan <= $2
  AND trang_thai = 'thanh_cong'
`

type GetRevenueByDateRangeParams struct {
	NgayThanhToan   pgtype.Timestamp `json:"ngay_thanh_toan"`
	NgayThanhToan_2 pgtype.Timestamp `json:"ngay_thanh_toan_2"`
}

type GetRevenueByDateRangeRow struct {
	TotalRevenue      interface{} `json:"total_revenue"`
	TotalTransactions int32       `json:"total_transactions"`
}

func (q *Queries) GetRevenueByDateRange(ctx context.Context, arg GetRevenueByDateRangeParams) (GetRevenueByDateRangeRow, error) {
	row := q.db.QueryRow(ctx, getRevenueByDateRange, arg.NgayThanhToan, arg.NgayThanhToan_2)
	var i GetRevenueByDateRangeRow
	err := row.Scan(&i.TotalRevenue, &i.TotalTransactions)
	return i, err
}

const getRevenueByMonth = `-- name: GetRevenueByMonth :many
SELECT
  EXTRACT(MONTH FROM ngay_thanh_toan) ::int AS month,
  COALESCE(SUM(so_tien), 0)                 AS revenue
FROM thanh_toan
WHERE EXTRACT(YEAR FROM ngay_thanh_toan) = $1
  AND trang_thai = 'thanh_cong'
GROUP BY month
ORDER BY month
`

type GetRevenueByMonthRow struct {
	Month   int32       `json:"month"`
	Revenue interface{} `json:"revenue"`
}

func (q *Queries) GetRevenueByMonth(ctx context.Context, ngayThanhToan pgtype.Timestamp) ([]GetRevenueByMonthRow, error) {
	rows, err := q.db.Query(ctx, getRevenueByMonth, ngayThanhToan)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetRevenueByMonthRow
	for rows.Next() {
		var i GetRevenueByMonthRow
		if err := rows.Scan(&i.Month, &i.Revenue); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRevenueBySupplier = `-- name: GetRevenueBySupplier :many
SELECT
  ncc.id                           AS supplier_id,
  ncc.ten                          AS supplier_name,
  COALESCE(SUM(tt.so_tien), 0)     AS total_revenue,
  COUNT(DISTINCT dc.id)::int       AS total_bookings
FROM nha_cung_cap ncc
LEFT JOIN tour t ON t.nha_cung_cap_id = ncc.id
LEFT JOIN khoi_hanh_tour kh ON kh.tour_id = t.id
LEFT JOIN dat_cho_tour dc ON dc.khoi_hanh_id = kh.id
LEFT JOIN thanh_toan tt ON tt.dat_cho_id = dc.id AND tt.trang_thai = 'thanh_cong'
WHERE ncc.dang_hoat_dong = TRUE
GROUP BY ncc.id, ncc.ten
ORDER BY total_revenue DESC
LIMIT $1
`

type GetRevenueBySupplierRow struct {
	SupplierID    int32       `json:"supplier_id"`
	SupplierName  string      `json:"supplier_name"`
	TotalRevenue  interface{} `json:"total_revenue"`
	TotalBookings int32       `json:"total_bookings"`
}

func (q *Queries) GetRevenueBySupplier(ctx context.Context, limit int32) ([]GetRevenueBySupplierRow, error) {
	rows, err := q.db.Query(ctx, getRevenueBySupplier, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetRevenueBySupplierRow
	for rows.Next() {
		var i GetRevenueBySupplierRow
		if err := rows.Scan(
			&i.SupplierID,
			&i.SupplierName,
			&i.TotalRevenue,
			&i.TotalBookings,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRevenueByYear = `-- name: GetRevenueByYear :many
SELECT
  EXTRACT(YEAR FROM ngay_thanh_toan) ::int AS year,
  COALESCE(SUM(so_tien), 0)                 AS revenue
FROM thanh_toan
WHERE EXTRACT(YEAR FROM ngay_thanh_toan) = $1
  AND trang_thai = 'thanh_cong'
GROUP BY year
ORDER BY year
`

type GetRevenueByYearRow struct {
	Year    int32       `json:"year"`
	Revenue interface{} `json:"revenue"`
}

func (q *Queries) GetRevenueByYear(ctx context.Context, ngayThanhToan pgtype.Timestamp) ([]GetRevenueByYearRow, error) {
	rows, err := q.db.Query(ctx, getRevenueByYear, ngayThanhToan)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetRevenueByYearRow
	for rows.Next() {
		var i GetRevenueByYearRow
		if err := rows.Scan(&i.Year, &i.Revenue); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getReviewStatsByTour = `-- name: GetReviewStatsByTour :many
SELECT
  t.id                           AS tour_id,
  t.tieu_de                      AS tour_title,
  COUNT(dg.id)::int              AS total_reviews,
  COALESCE(AVG(dg.rating), 0)::float AS avg_rating,
  COUNT(CASE WHEN dg.rating = 5 THEN 1 END)::int AS five_star,
  COUNT(CASE WHEN dg.rating = 4 THEN 1 END)::int AS four_star,
  COUNT(CASE WHEN dg.rating = 3 THEN 1 END)::int AS three_star,
  COUNT(CASE WHEN dg.rating = 2 THEN 1 END)::int AS two_star,
  COUNT(CASE WHEN dg.rating = 1 THEN 1 END)::int AS one_star
FROM tour t
LEFT JOIN danh_gia dg ON dg.tour_id = t.id AND dg.dang_hoat_dong = TRUE
WHERE t.dang_hoat_dong = TRUE
GROUP BY t.id, t.tieu_de
HAVING COUNT(dg.id) > 0
ORDER BY avg_rating DESC, total_reviews DESC
LIMIT $1
`

type GetReviewStatsByTourRow struct {
	TourID       int32   `json:"tour_id"`
	TourTitle    string  `json:"tour_title"`
	TotalReviews int32   `json:"total_reviews"`
	AvgRating    float64 `json:"avg_rating"`
	FiveStar     int32   `json:"five_star"`
	FourStar     int32   `json:"four_star"`
	ThreeStar    int32   `json:"three_star"`
	TwoStar      int32   `json:"two_star"`
	OneStar      int32   `json:"one_star"`
}

func (q *Queries) GetReviewStatsByTour(ctx context.Context, limit int32) ([]GetReviewStatsByTourRow, error) {
	rows, err := q.db.Query(ctx, getReviewStatsByTour, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetReviewStatsByTourRow
	for rows.Next() {
		var i GetReviewStatsByTourRow
		if err := rows.Scan(
			&i.TourID,
			&i.TourTitle,
			&i.TotalReviews,
			&i.AvgRating,
			&i.FiveStar,
			&i.FourStar,
			&i.ThreeStar,
			&i.TwoStar,
			&i.OneStar,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTopCustomers = `-- name: GetTopCustomers :many
SELECT
  nd.id                                AS user_id,
  nd.ho_ten                            AS user_name,
  nd.email                             AS user_email,
  COUNT(dc.id)::int                    AS total_bookings,
  COALESCE(SUM(tt.so_tien), 0)         AS total_spent
FROM nguoi_dung nd
JOIN dat_cho_tour dc ON dc.nguoi_dung_id = nd.id
LEFT JOIN thanh_toan tt ON tt.dat_cho_id = dc.id AND tt.trang_thai = 'thanh_cong'
WHERE nd.dang_hoat_dong = TRUE
GROUP BY nd.id, nd.ho_ten, nd.email
ORDER BY total_spent DESC, total_bookings DESC
LIMIT $1
`

type GetTopCustomersRow struct {
	UserID        pgtype.UUID `json:"user_id"`
	UserName      string      `json:"user_name"`
	UserEmail     string      `json:"user_email"`
	TotalBookings int32       `json:"total_bookings"`
	TotalSpent    interface{} `json:"total_spent"`
}

func (q *Queries) GetTopCustomers(ctx context.Context, limit int32) ([]GetTopCustomersRow, error) {
	rows, err := q.db.Query(ctx, getTopCustomers, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTopCustomersRow
	for rows.Next() {
		var i GetTopCustomersRow
		if err := rows.Scan(
			&i.UserID,
			&i.UserName,
			&i.UserEmail,
			&i.TotalBookings,
			&i.TotalSpent,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTopSuppliers = `-- name: GetTopSuppliers :many
SELECT
  ncc.id                     AS supplier_id,
  ncc.ten                    AS supplier_name,
  COUNT(t.id)::int           AS total_tours,
  COUNT(dc.id)::int          AS total_bookings
FROM nha_cung_cap ncc
LEFT JOIN tour t ON t.nha_cung_cap_id = ncc.id
LEFT JOIN khoi_hanh_tour kh ON kh.tour_id = t.id
LEFT JOIN dat_cho_tour dc ON dc.khoi_hanh_id = kh.id
WHERE ncc.dang_hoat_dong = TRUE
GROUP BY ncc.id, ncc.ten
ORDER BY total_bookings DESC, total_tours DESC
LIMIT $1
`

type GetTopSuppliersRow struct {
	SupplierID    int32  `json:"supplier_id"`
	SupplierName  string `json:"supplier_name"`
	TotalTours    int32  `json:"total_tours"`
	TotalBookings int32  `json:"total_bookings"`
}

func (q *Queries) GetTopSuppliers(ctx context.Context, limit int32) ([]GetTopSuppliersRow, error) {
	rows, err := q.db.Query(ctx, getTopSuppliers, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTopSuppliersRow
	for rows.Next() {
		var i GetTopSuppliersRow
		if err := rows.Scan(
			&i.SupplierID,
			&i.SupplierName,
			&i.TotalTours,
			&i.TotalBookings,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTopToursByBookings = `-- name: GetTopToursByBookings :many
SELECT
  t.id                         AS tour_id,
  t.tieu_de                    AS tour_title,
  COUNT(dc.id)::int            AS bookings
FROM dat_cho_tour dc
JOIN khoi_hanh_tour kh ON kh.id = dc.khoi_hanh_id
JOIN tour t          ON t.id  = kh.tour_id
GROUP BY t.id, t.tieu_de
ORDER BY bookings DESC, t.id ASC
LIMIT $1
`

type GetTopToursByBookingsRow struct {
	TourID    int32  `json:"tour_id"`
	TourTitle string `json:"tour_title"`
	Bookings  int32  `json:"bookings"`
}

func (q *Queries) GetTopToursByBookings(ctx context.Context, limit int32) ([]GetTopToursByBookingsRow, error) {
	rows, err := q.db.Query(ctx, getTopToursByBookings, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTopToursByBookingsRow
	for rows.Next() {
		var i GetTopToursByBookingsRow
		if err := rows.Scan(&i.TourID, &i.TourTitle, &i.Bookings); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getToursByCategory = `-- name: GetToursByCategory :many
SELECT
  dm.id                      AS category_id,
  dm.ten                     AS category_name,
  COUNT(t.id)::int           AS total_tours,
  COUNT(dc.id)::int          AS total_bookings
FROM danh_muc_tour dm
LEFT JOIN tour t ON t.danh_muc_id = dm.id
LEFT JOIN khoi_hanh_tour kh ON kh.tour_id = t.id
LEFT JOIN dat_cho_tour dc ON dc.khoi_hanh_id = kh.id
WHERE dm.dang_hoat_dong = TRUE
GROUP BY dm.id, dm.ten
ORDER BY total_bookings DESC, total_tours DESC
`

type GetToursByCategoryRow struct {
	CategoryID    int32  `json:"category_id"`
	CategoryName  string `json:"category_name"`
	TotalTours    int32  `json:"total_tours"`
	TotalBookings int32  `json:"total_bookings"`
}

func (q *Queries) GetToursByCategory(ctx context.Context) ([]GetToursByCategoryRow, error) {
	rows, err := q.db.Query(ctx, getToursByCategory)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetToursByCategoryRow
	for rows.Next() {
		var i GetToursByCategoryRow
		if err := rows.Scan(
			&i.CategoryID,
			&i.CategoryName,
			&i.TotalTours,
			&i.TotalBookings,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUpcomingDepartures = `-- name: GetUpcomingDepartures :many
SELECT
  kh.id                      AS departure_id,
  kh.ngay_khoi_hanh          AS departure_date,
  t.tieu_de                  AS tour_title,
  kh.suc_chua                AS capacity,
  COUNT(dc.id)::int          AS booked,
  kh.suc_chua - COUNT(dc.id)::int AS available
FROM khoi_hanh_tour kh
JOIN tour t ON t.id = kh.tour_id
LEFT JOIN dat_cho_tour dc ON dc.khoi_hanh_id = kh.id 
  AND dc.trang_thai IN ('cho_xac_nhan', 'da_xac_nhan', 'da_thanh_toan')
WHERE kh.ngay_khoi_hanh >= CURRENT_DATE
  AND kh.trang_thai IN ('len_lich', 'xac_nhan')
GROUP BY kh.id, kh.ngay_khoi_hanh, t.tieu_de, kh.suc_chua
ORDER BY kh.ngay_khoi_hanh ASC
LIMIT $1
`

type GetUpcomingDeparturesRow struct {
	DepartureID   int32       `json:"departure_id"`
	DepartureDate pgtype.Date `json:"departure_date"`
	TourTitle     string      `json:"tour_title"`
	Capacity      int32       `json:"capacity"`
	Booked        int32       `json:"booked"`
	Available     int32       `json:"available"`
}

func (q *Queries) GetUpcomingDepartures(ctx context.Context, limit int32) ([]GetUpcomingDeparturesRow, error) {
	rows, err := q.db.Query(ctx, getUpcomingDepartures, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetUpcomingDeparturesRow
	for rows.Next() {
		var i GetUpcomingDeparturesRow
		if err := rows.Scan(
			&i.DepartureID,
			&i.DepartureDate,
			&i.TourTitle,
			&i.Capacity,
			&i.Booked,
			&i.Available,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserGrowth = `-- name: GetUserGrowth :many
SELECT
  DATE(ngay_tao) AS date,
  COUNT(*)::int  AS new_users
FROM nguoi_dung
WHERE ngay_tao >= $1 AND ngay_tao <= $2
GROUP BY date
ORDER BY date ASC
`

type GetUserGrowthParams struct {
	NgayTao   pgtype.Timestamp `json:"ngay_tao"`
	NgayTao_2 pgtype.Timestamp `json:"ngay_tao_2"`
}

type GetUserGrowthRow struct {
	Date     pgtype.Date `json:"date"`
	NewUsers int32       `json:"new_users"`
}

func (q *Queries) GetUserGrowth(ctx context.Context, arg GetUserGrowthParams) ([]GetUserGrowthRow, error) {
	rows, err := q.db.Query(ctx, getUserGrowth, arg.NgayTao, arg.NgayTao_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetUserGrowthRow
	for rows.Next() {
		var i GetUserGrowthRow
		if err := rows.Scan(&i.Date, &i.NewUsers); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
