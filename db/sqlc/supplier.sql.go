// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: supplier.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const approveSupplier = `-- name: ApproveSupplier :one
UPDATE nguoi_dung
SET 
    dang_hoat_dong = TRUE,
    xac_thuc = TRUE,
    ngay_cap_nhat = CURRENT_TIMESTAMP
WHERE id = $1 
    AND vai_tro = 'nha_cung_cap'
    AND dang_hoat_dong = FALSE
RETURNING id, ho_ten, email, mat_khau_ma_hoa, so_dien_thoai, vai_tro, dang_hoat_dong, xac_thuc, ngay_tao, ngay_cap_nhat
`

// phê duyệt nhà cung cấp
func (q *Queries) ApproveSupplier(ctx context.Context, id pgtype.UUID) (NguoiDung, error) {
	row := q.db.QueryRow(ctx, approveSupplier, id)
	var i NguoiDung
	err := row.Scan(
		&i.ID,
		&i.HoTen,
		&i.Email,
		&i.MatKhauMaHoa,
		&i.SoDienThoai,
		&i.VaiTro,
		&i.DangHoatDong,
		&i.XacThuc,
		&i.NgayTao,
		&i.NgayCapNhat,
	)
	return i, err
}

const bulkUpdateSupplierStatus = `-- name: BulkUpdateSupplierStatus :exec
UPDATE nha_cung_cap
SET
    ngay_cap_nhat = CURRENT_TIMESTAMP
WHERE id = ANY($1::int[]) AND nguoi_dung.dang_hoat_dong = TRUE
`

// cập nhật trạng thái nhà cung cấp hàng loạt
func (q *Queries) BulkUpdateSupplierStatus(ctx context.Context, dollar_1 []int32) error {
	_, err := q.db.Exec(ctx, bulkUpdateSupplierStatus, dollar_1)
	return err
}

const countSupplierBookingsByStatusAdvanced = `-- name: CountSupplierBookingsByStatusAdvanced :one
SELECT COUNT(*)::int AS total_count
FROM nha_cung_cap ncc
JOIN tour t ON t.nha_cung_cap_id = ncc.id AND t.dang_hoat_dong = TRUE
JOIN khoi_hanh_tour kh ON kh.tour_id = t.id
JOIN dat_cho dc ON dc.khoi_hanh_id = kh.id
JOIN nguoi_dung nd ON nd.id = dc.nguoi_dung_id
WHERE ncc.id = $1
    -- Filter theo trạng thái
    AND (
        $2::text IS NULL 
        OR $2::text = ''
        OR dc.trang_thai::text = $2::text
    )
    -- Filter theo tour ID
    AND ($3::int IS NULL OR t.id = $3::int)
    -- Filter theo khoảng thời gian đặt chỗ
    AND ($4::timestamp IS NULL OR dc.ngay_dat >= $4::timestamp)
    AND ($5::timestamp IS NULL OR dc.ngay_dat <= $5::timestamp)
    -- Filter theo khoảng thời gian khởi hành
    AND ($6::date IS NULL OR kh.ngay_khoi_hanh >= $6::date)
    AND ($7::date IS NULL OR kh.ngay_khoi_hanh <= $7::date)
    -- Search theo tên khách hàng hoặc email
    AND (
        $8::text IS NULL 
        OR $8::text = ''
        OR nd.ho_ten ILIKE '%' || $8::text || '%'
        OR nd.email ILIKE '%' || $8::text || '%'
        OR t.tieu_de ILIKE '%' || $8::text || '%'
    )
    -- Filter theo phương thức thanh toán
    AND (
        $9::text IS NULL 
        OR $9::text = ''
        OR dc.phuong_thuc_thanh_toan::text = $9::text
    )
    -- Filter theo khoảng giá
    AND ($10::numeric IS NULL OR dc.tong_tien >= $10::numeric)
    AND ($11::numeric IS NULL OR dc.tong_tien <= $11::numeric)
`

type CountSupplierBookingsByStatusAdvancedParams struct {
	ID                  pgtype.UUID      `json:"id"`
	TrangThai           *string          `json:"trang_thai"`
	TourID              *int32           `json:"tour_id"`
	StartDate           pgtype.Timestamp `json:"start_date"`
	EndDate             pgtype.Timestamp `json:"end_date"`
	DepartureStartDate  pgtype.Date      `json:"departure_start_date"`
	DepartureEndDate    pgtype.Date      `json:"departure_end_date"`
	SearchKeyword       *string          `json:"search_keyword"`
	PhuongThucThanhToan *string          `json:"phuong_thuc_thanh_toan"`
	MinAmount           pgtype.Numeric   `json:"min_amount"`
	MaxAmount           pgtype.Numeric   `json:"max_amount"`
}

// Đếm tổng số booking theo các filter nâng cao
func (q *Queries) CountSupplierBookingsByStatusAdvanced(ctx context.Context, arg CountSupplierBookingsByStatusAdvancedParams) (int32, error) {
	row := q.db.QueryRow(ctx, countSupplierBookingsByStatusAdvanced,
		arg.ID,
		arg.TrangThai,
		arg.TourID,
		arg.StartDate,
		arg.EndDate,
		arg.DepartureStartDate,
		arg.DepartureEndDate,
		arg.SearchKeyword,
		arg.PhuongThucThanhToan,
		arg.MinAmount,
		arg.MaxAmount,
	)
	var total_count int32
	err := row.Scan(&total_count)
	return total_count, err
}

const countSuppliers = `-- name: CountSuppliers :one
SELECT COUNT(*)::int FROM nha_cung_cap
JOIN nguoi_dung ON nguoi_dung.id = nha_cung_cap.id
`

func (q *Queries) CountSuppliers(ctx context.Context) (int32, error) {
	row := q.db.QueryRow(ctx, countSuppliers)
	var column_1 int32
	err := row.Scan(&column_1)
	return column_1, err
}

const countSuppliersByStatus = `-- name: CountSuppliersByStatus :many
SELECT
    nguoi_dung.dang_hoat_dong,
    COUNT(*)::int AS total
FROM nha_cung_cap
JOIN nguoi_dung ON nguoi_dung.id = nha_cung_cap.id
WHERE nguoi_dung.dang_hoat_dong = TRUE AND nguoi_dung.email = $1
GROUP BY nguoi_dung.dang_hoat_dong
ORDER BY nguoi_dung.dang_hoat_dong DESC
`

type CountSuppliersByStatusRow struct {
	DangHoatDong *bool `json:"dang_hoat_dong"`
	Total        int32 `json:"total"`
}

// đếm số lượng nhà cung cấp theo trạng thái
func (q *Queries) CountSuppliersByStatus(ctx context.Context, email string) ([]CountSuppliersByStatusRow, error) {
	rows, err := q.db.Query(ctx, countSuppliersByStatus, email)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []CountSuppliersByStatusRow
	for rows.Next() {
		var i CountSuppliersByStatusRow
		if err := rows.Scan(&i.DangHoatDong, &i.Total); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const createSupplier = `-- name: CreateSupplier :one
insert into nha_cung_cap (id, ten, dia_chi, website, mo_ta, logo)
values ($1, $2, $3, $4, $5, $6)
returning id, ten, dia_chi, website, mo_ta, logo, nam_thanh_lap, thanh_pho, quoc_gia, ma_so_thue, so_nhan_vien, giay_to_kinh_doanh
`

type CreateSupplierParams struct {
	ID      pgtype.UUID `json:"id"`
	Ten     string      `json:"ten"`
	DiaChi  *string     `json:"dia_chi"`
	Website *string     `json:"website"`
	MoTa    *string     `json:"mo_ta"`
	Logo    *string     `json:"logo"`
}

func (q *Queries) CreateSupplier(ctx context.Context, arg CreateSupplierParams) (NhaCungCap, error) {
	row := q.db.QueryRow(ctx, createSupplier,
		arg.ID,
		arg.Ten,
		arg.DiaChi,
		arg.Website,
		arg.MoTa,
		arg.Logo,
	)
	var i NhaCungCap
	err := row.Scan(
		&i.ID,
		&i.Ten,
		&i.DiaChi,
		&i.Website,
		&i.MoTa,
		&i.Logo,
		&i.NamThanhLap,
		&i.ThanhPho,
		&i.QuocGia,
		&i.MaSoThue,
		&i.SoNhanVien,
		&i.GiayToKinhDoanh,
	)
	return i, err
}

const deleteSupplier = `-- name: DeleteSupplier :exec
DELETE FROM nha_cung_cap
WHERE id = $1 AND nha_cung_cap.dang_hoat_dong = TRUE
`

func (q *Queries) DeleteSupplier(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteSupplier, id)
	return err
}

const getActiveSuppliers = `-- name: GetActiveSuppliers :many
SELECT nha_cung_cap.id, ten, dia_chi, website, mo_ta, logo, nam_thanh_lap, thanh_pho, quoc_gia, ma_so_thue, so_nhan_vien, giay_to_kinh_doanh, nguoi_dung.id, ho_ten, email, mat_khau_ma_hoa, so_dien_thoai, vai_tro, dang_hoat_dong, xac_thuc, ngay_tao, ngay_cap_nhat FROM nha_cung_cap
JOIN nguoi_dung ON nguoi_dung.id = nha_cung_cap.id
WHERE nguoi_dung.dang_hoat_dong = TRUE
ORDER BY nguoi_dung.ngay_tao DESC
`

type GetActiveSuppliersRow struct {
	ID              pgtype.UUID         `json:"id"`
	Ten             string              `json:"ten"`
	DiaChi          *string             `json:"dia_chi"`
	Website         *string             `json:"website"`
	MoTa            *string             `json:"mo_ta"`
	Logo            *string             `json:"logo"`
	NamThanhLap     pgtype.Date         `json:"nam_thanh_lap"`
	ThanhPho        *string             `json:"thanh_pho"`
	QuocGia         *string             `json:"quoc_gia"`
	MaSoThue        *string             `json:"ma_so_thue"`
	SoNhanVien      *string             `json:"so_nhan_vien"`
	GiayToKinhDoanh *string             `json:"giay_to_kinh_doanh"`
	ID_2            pgtype.UUID         `json:"id_2"`
	HoTen           string              `json:"ho_ten"`
	Email           string              `json:"email"`
	MatKhauMaHoa    string              `json:"mat_khau_ma_hoa"`
	SoDienThoai     *string             `json:"so_dien_thoai"`
	VaiTro          NullVaiTroNguoiDung `json:"vai_tro"`
	DangHoatDong    *bool               `json:"dang_hoat_dong"`
	XacThuc         *bool               `json:"xac_thuc"`
	NgayTao         pgtype.Timestamp    `json:"ngay_tao"`
	NgayCapNhat     pgtype.Timestamp    `json:"ngay_cap_nhat"`
}

func (q *Queries) GetActiveSuppliers(ctx context.Context) ([]GetActiveSuppliersRow, error) {
	rows, err := q.db.Query(ctx, getActiveSuppliers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetActiveSuppliersRow
	for rows.Next() {
		var i GetActiveSuppliersRow
		if err := rows.Scan(
			&i.ID,
			&i.Ten,
			&i.DiaChi,
			&i.Website,
			&i.MoTa,
			&i.Logo,
			&i.NamThanhLap,
			&i.ThanhPho,
			&i.QuocGia,
			&i.MaSoThue,
			&i.SoNhanVien,
			&i.GiayToKinhDoanh,
			&i.ID_2,
			&i.HoTen,
			&i.Email,
			&i.MatKhauMaHoa,
			&i.SoDienThoai,
			&i.VaiTro,
			&i.DangHoatDong,
			&i.XacThuc,
			&i.NgayTao,
			&i.NgayCapNhat,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllSuppliers = `-- name: GetAllSuppliers :many
SELECT nha_cung_cap.id, ten, dia_chi, website, mo_ta, logo, nam_thanh_lap, thanh_pho, quoc_gia, ma_so_thue, so_nhan_vien, giay_to_kinh_doanh, nguoi_dung.id, ho_ten, email, mat_khau_ma_hoa, so_dien_thoai, vai_tro, dang_hoat_dong, xac_thuc, ngay_tao, ngay_cap_nhat FROM nha_cung_cap
JOIN nguoi_dung ON nguoi_dung.id = nha_cung_cap.id
WHERE nguoi_dung.dang_hoat_dong = TRUE
ORDER BY nguoi_dung.ngay_tao DESC
`

type GetAllSuppliersRow struct {
	ID              pgtype.UUID         `json:"id"`
	Ten             string              `json:"ten"`
	DiaChi          *string             `json:"dia_chi"`
	Website         *string             `json:"website"`
	MoTa            *string             `json:"mo_ta"`
	Logo            *string             `json:"logo"`
	NamThanhLap     pgtype.Date         `json:"nam_thanh_lap"`
	ThanhPho        *string             `json:"thanh_pho"`
	QuocGia         *string             `json:"quoc_gia"`
	MaSoThue        *string             `json:"ma_so_thue"`
	SoNhanVien      *string             `json:"so_nhan_vien"`
	GiayToKinhDoanh *string             `json:"giay_to_kinh_doanh"`
	ID_2            pgtype.UUID         `json:"id_2"`
	HoTen           string              `json:"ho_ten"`
	Email           string              `json:"email"`
	MatKhauMaHoa    string              `json:"mat_khau_ma_hoa"`
	SoDienThoai     *string             `json:"so_dien_thoai"`
	VaiTro          NullVaiTroNguoiDung `json:"vai_tro"`
	DangHoatDong    *bool               `json:"dang_hoat_dong"`
	XacThuc         *bool               `json:"xac_thuc"`
	NgayTao         pgtype.Timestamp    `json:"ngay_tao"`
	NgayCapNhat     pgtype.Timestamp    `json:"ngay_cap_nhat"`
}

func (q *Queries) GetAllSuppliers(ctx context.Context) ([]GetAllSuppliersRow, error) {
	rows, err := q.db.Query(ctx, getAllSuppliers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllSuppliersRow
	for rows.Next() {
		var i GetAllSuppliersRow
		if err := rows.Scan(
			&i.ID,
			&i.Ten,
			&i.DiaChi,
			&i.Website,
			&i.MoTa,
			&i.Logo,
			&i.NamThanhLap,
			&i.ThanhPho,
			&i.QuocGia,
			&i.MaSoThue,
			&i.SoNhanVien,
			&i.GiayToKinhDoanh,
			&i.ID_2,
			&i.HoTen,
			&i.Email,
			&i.MatKhauMaHoa,
			&i.SoDienThoai,
			&i.VaiTro,
			&i.DangHoatDong,
			&i.XacThuc,
			&i.NgayTao,
			&i.NgayCapNhat,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllSuppliersIncludingDeleted = `-- name: GetAllSuppliersIncludingDeleted :many
SELECT nha_cung_cap.id, ten, dia_chi, website, mo_ta, logo, nam_thanh_lap, thanh_pho, quoc_gia, ma_so_thue, so_nhan_vien, giay_to_kinh_doanh, nguoi_dung.id, ho_ten, email, mat_khau_ma_hoa, so_dien_thoai, vai_tro, dang_hoat_dong, xac_thuc, ngay_tao, ngay_cap_nhat FROM nha_cung_cap
JOIN nguoi_dung ON nguoi_dung.id = nha_cung_cap.id
ORDER BY nguoi_dung.ngay_tao DESC
`

type GetAllSuppliersIncludingDeletedRow struct {
	ID              pgtype.UUID         `json:"id"`
	Ten             string              `json:"ten"`
	DiaChi          *string             `json:"dia_chi"`
	Website         *string             `json:"website"`
	MoTa            *string             `json:"mo_ta"`
	Logo            *string             `json:"logo"`
	NamThanhLap     pgtype.Date         `json:"nam_thanh_lap"`
	ThanhPho        *string             `json:"thanh_pho"`
	QuocGia         *string             `json:"quoc_gia"`
	MaSoThue        *string             `json:"ma_so_thue"`
	SoNhanVien      *string             `json:"so_nhan_vien"`
	GiayToKinhDoanh *string             `json:"giay_to_kinh_doanh"`
	ID_2            pgtype.UUID         `json:"id_2"`
	HoTen           string              `json:"ho_ten"`
	Email           string              `json:"email"`
	MatKhauMaHoa    string              `json:"mat_khau_ma_hoa"`
	SoDienThoai     *string             `json:"so_dien_thoai"`
	VaiTro          NullVaiTroNguoiDung `json:"vai_tro"`
	DangHoatDong    *bool               `json:"dang_hoat_dong"`
	XacThuc         *bool               `json:"xac_thuc"`
	NgayTao         pgtype.Timestamp    `json:"ngay_tao"`
	NgayCapNhat     pgtype.Timestamp    `json:"ngay_cap_nhat"`
}

func (q *Queries) GetAllSuppliersIncludingDeleted(ctx context.Context) ([]GetAllSuppliersIncludingDeletedRow, error) {
	rows, err := q.db.Query(ctx, getAllSuppliersIncludingDeleted)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllSuppliersIncludingDeletedRow
	for rows.Next() {
		var i GetAllSuppliersIncludingDeletedRow
		if err := rows.Scan(
			&i.ID,
			&i.Ten,
			&i.DiaChi,
			&i.Website,
			&i.MoTa,
			&i.Logo,
			&i.NamThanhLap,
			&i.ThanhPho,
			&i.QuocGia,
			&i.MaSoThue,
			&i.SoNhanVien,
			&i.GiayToKinhDoanh,
			&i.ID_2,
			&i.HoTen,
			&i.Email,
			&i.MatKhauMaHoa,
			&i.SoDienThoai,
			&i.VaiTro,
			&i.DangHoatDong,
			&i.XacThuc,
			&i.NgayTao,
			&i.NgayCapNhat,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMyTours = `-- name: GetMyTours :many
SELECT id, tieu_de, mo_ta, danh_muc_id, so_ngay, so_dem, gia_nguoi_lon, gia_tre_em, don_vi_tien_te, trang_thai, noi_bat, nha_cung_cap_id, dang_hoat_dong, ngay_tao, ngay_cap_nhat FROM tour
WHERE nha_cung_cap_id = $1 
  AND dang_hoat_dong = TRUE 
  AND ($4::TEXT IS NULL OR $4::TEXT = '' OR trang_thai = $4::TEXT)
ORDER BY ngay_tao DESC
LIMIT $2 OFFSET $3
`

type GetMyToursParams struct {
	NhaCungCapID pgtype.UUID `json:"nha_cung_cap_id"`
	Limit        int32       `json:"limit"`
	Offset       int32       `json:"offset"`
	TrangThai    *string     `json:"trang_thai"`
}

// lấy danh sách tour của nhà cung cấp
func (q *Queries) GetMyTours(ctx context.Context, arg GetMyToursParams) ([]Tour, error) {
	rows, err := q.db.Query(ctx, getMyTours,
		arg.NhaCungCapID,
		arg.Limit,
		arg.Offset,
		arg.TrangThai,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Tour
	for rows.Next() {
		var i Tour
		if err := rows.Scan(
			&i.ID,
			&i.TieuDe,
			&i.MoTa,
			&i.DanhMucID,
			&i.SoNgay,
			&i.SoDem,
			&i.GiaNguoiLon,
			&i.GiaTreEm,
			&i.DonViTienTe,
			&i.TrangThai,
			&i.NoiBat,
			&i.NhaCungCapID,
			&i.DangHoatDong,
			&i.NgayTao,
			&i.NgayCapNhat,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPendingSuppliers = `-- name: GetPendingSuppliers :many
SELECT 
    nha_cung_cap.id, nha_cung_cap.ten, nha_cung_cap.dia_chi, nha_cung_cap.website, nha_cung_cap.mo_ta, nha_cung_cap.logo, nha_cung_cap.nam_thanh_lap, nha_cung_cap.thanh_pho, nha_cung_cap.quoc_gia, nha_cung_cap.ma_so_thue, nha_cung_cap.so_nhan_vien, nha_cung_cap.giay_to_kinh_doanh,
    nguoi_dung.ho_ten,
    nguoi_dung.email,
    nguoi_dung.so_dien_thoai,
    nguoi_dung.ngay_tao,
    nguoi_dung.ngay_cap_nhat,
    nguoi_dung.dang_hoat_dong,
    nguoi_dung.xac_thuc
FROM nha_cung_cap
JOIN nguoi_dung ON nguoi_dung.id = nha_cung_cap.id
WHERE nguoi_dung.vai_tro = 'nha_cung_cap'
    AND (nguoi_dung.dang_hoat_dong = FALSE OR nguoi_dung.xac_thuc = FALSE)
ORDER BY nguoi_dung.ngay_tao DESC
`

type GetPendingSuppliersRow struct {
	ID              pgtype.UUID      `json:"id"`
	Ten             string           `json:"ten"`
	DiaChi          *string          `json:"dia_chi"`
	Website         *string          `json:"website"`
	MoTa            *string          `json:"mo_ta"`
	Logo            *string          `json:"logo"`
	NamThanhLap     pgtype.Date      `json:"nam_thanh_lap"`
	ThanhPho        *string          `json:"thanh_pho"`
	QuocGia         *string          `json:"quoc_gia"`
	MaSoThue        *string          `json:"ma_so_thue"`
	SoNhanVien      *string          `json:"so_nhan_vien"`
	GiayToKinhDoanh *string          `json:"giay_to_kinh_doanh"`
	HoTen           string           `json:"ho_ten"`
	Email           string           `json:"email"`
	SoDienThoai     *string          `json:"so_dien_thoai"`
	NgayTao         pgtype.Timestamp `json:"ngay_tao"`
	NgayCapNhat     pgtype.Timestamp `json:"ngay_cap_nhat"`
	DangHoatDong    *bool            `json:"dang_hoat_dong"`
	XacThuc         *bool            `json:"xac_thuc"`
}

// lấy danh sách nhà cung cấp chờ phê duyệt
func (q *Queries) GetPendingSuppliers(ctx context.Context) ([]GetPendingSuppliersRow, error) {
	rows, err := q.db.Query(ctx, getPendingSuppliers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetPendingSuppliersRow
	for rows.Next() {
		var i GetPendingSuppliersRow
		if err := rows.Scan(
			&i.ID,
			&i.Ten,
			&i.DiaChi,
			&i.Website,
			&i.MoTa,
			&i.Logo,
			&i.NamThanhLap,
			&i.ThanhPho,
			&i.QuocGia,
			&i.MaSoThue,
			&i.SoNhanVien,
			&i.GiayToKinhDoanh,
			&i.HoTen,
			&i.Email,
			&i.SoDienThoai,
			&i.NgayTao,
			&i.NgayCapNhat,
			&i.DangHoatDong,
			&i.XacThuc,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSupplierBookingStatsByStatus = `-- name: GetSupplierBookingStatsByStatus :many
SELECT 
    dc.trang_thai,
    COUNT(DISTINCT dc.id)::int AS booking_count,
    COALESCE(SUM(dc.tong_tien), 0)::numeric AS total_amount,
    COALESCE(SUM(dc.so_nguoi_lon + dc.so_tre_em), 0)::int AS total_passengers,
    MIN(dc.ngay_dat)::timestamp AS first_booking_date,
    MAX(dc.ngay_dat)::timestamp AS last_booking_date
FROM nha_cung_cap ncc
JOIN tour t ON t.nha_cung_cap_id = ncc.id AND t.dang_hoat_dong = TRUE
JOIN khoi_hanh_tour kh ON kh.tour_id = t.id
JOIN dat_cho dc ON dc.khoi_hanh_id = kh.id
WHERE ncc.id = $1
    AND ($2::timestamp IS NULL OR dc.ngay_dat >= $2)
    AND ($3::timestamp IS NULL OR dc.ngay_dat <= $3)
GROUP BY dc.trang_thai
ORDER BY booking_count DESC
`

type GetSupplierBookingStatsByStatusParams struct {
	ID      pgtype.UUID      `json:"id"`
	Column2 pgtype.Timestamp `json:"column_2"`
	Column3 pgtype.Timestamp `json:"column_3"`
}

type GetSupplierBookingStatsByStatusRow struct {
	TrangThai        NullTrangThaiDatCho `json:"trang_thai"`
	BookingCount     int32               `json:"booking_count"`
	TotalAmount      pgtype.Numeric      `json:"total_amount"`
	TotalPassengers  int32               `json:"total_passengers"`
	FirstBookingDate pgtype.Timestamp    `json:"first_booking_date"`
	LastBookingDate  pgtype.Timestamp    `json:"last_booking_date"`
}

// Thống kê booking theo trạng thái và thời gian
func (q *Queries) GetSupplierBookingStatsByStatus(ctx context.Context, arg GetSupplierBookingStatsByStatusParams) ([]GetSupplierBookingStatsByStatusRow, error) {
	rows, err := q.db.Query(ctx, getSupplierBookingStatsByStatus, arg.ID, arg.Column2, arg.Column3)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetSupplierBookingStatsByStatusRow
	for rows.Next() {
		var i GetSupplierBookingStatsByStatusRow
		if err := rows.Scan(
			&i.TrangThai,
			&i.BookingCount,
			&i.TotalAmount,
			&i.TotalPassengers,
			&i.FirstBookingDate,
			&i.LastBookingDate,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSupplierBookingsByStatusAdvanced = `-- name: GetSupplierBookingsByStatusAdvanced :many
SELECT 
    dc.id AS booking_id,
    dc.ngay_dat,
    dc.trang_thai,
    dc.tong_tien,
    dc.don_vi_tien_te,
    dc.so_nguoi_lon,
    dc.so_tre_em,
    dc.phuong_thuc_thanh_toan,
    dc.ngay_cap_nhat,
    
    -- Thông tin khách hàng
    nd.id AS customer_id,
    nd.ho_ten AS customer_name,
    nd.email AS customer_email,
    nd.so_dien_thoai AS customer_phone,
    
    -- Thông tin tour
    t.id AS tour_id,
    t.tieu_de AS tour_title,
    t.gia_nguoi_lon AS tour_price_adult,
    t.gia_tre_em AS tour_price_child,
    t.don_vi_tien_te AS tour_currency,
    (
        SELECT a.duong_dan
        FROM anh_tour a
        WHERE a.tour_id = t.id AND a.la_anh_chinh = TRUE
        LIMIT 1
    ) AS tour_image,
    
    -- Thông tin khởi hành
    kh.id AS departure_id,
    kh.ngay_khoi_hanh,
    kh.ngay_ket_thuc,
    kh.suc_chua AS departure_capacity,
    kh.so_cho_da_dat AS departure_booked,
    (kh.suc_chua - kh.so_cho_da_dat) AS departure_available,
    kh.trang_thai AS departure_status,
    
    -- Thông tin hành khách
    (
        SELECT COUNT(*)
        FROM hanh_khach hk
        WHERE hk.dat_cho_id = dc.id
    )::int AS passenger_count,
    
    -- Thông tin thanh toán
    (
        SELECT COUNT(*)
        FROM lich_su_giao_dich lsgd
        WHERE lsgd.dat_cho_id = dc.id
            AND lsgd.trang_thai = 'thanh_cong'
    )::int AS successful_payments,
    
    -- Tính toán
    (dc.so_nguoi_lon + dc.so_tre_em) AS total_passengers,
    CASE 
        WHEN dc.trang_thai IN ('da_thanh_toan', 'hoan_thanh') THEN dc.tong_tien
        ELSE 0
    END::numeric AS confirmed_revenue
FROM nha_cung_cap ncc
JOIN tour t ON t.nha_cung_cap_id = ncc.id AND t.dang_hoat_dong = TRUE
JOIN khoi_hanh_tour kh ON kh.tour_id = t.id
JOIN dat_cho dc ON dc.khoi_hanh_id = kh.id
JOIN nguoi_dung nd ON nd.id = dc.nguoi_dung_id
WHERE ncc.id = $1
    -- Filter theo trạng thái
    AND (
        $4::text IS NULL 
        OR $4::text = ''
        OR dc.trang_thai::text = $4::text
    )
    -- Filter theo tour ID
    AND ($5::int IS NULL OR t.id = $5::int)
    -- Filter theo khoảng thời gian đặt chỗ
    AND ($6::timestamp IS NULL OR dc.ngay_dat >= $6::timestamp)
    AND ($7::timestamp IS NULL OR dc.ngay_dat <= $7::timestamp)
    -- Filter theo khoảng thời gian khởi hành
    AND ($8::date IS NULL OR kh.ngay_khoi_hanh >= $8::date)
    AND ($9::date IS NULL OR kh.ngay_khoi_hanh <= $9::date)
    -- Search theo tên khách hàng hoặc email
    AND (
        $10::text IS NULL 
        OR $10::text = ''
        OR nd.ho_ten ILIKE '%' || $10::text || '%'
        OR nd.email ILIKE '%' || $10::text || '%'
        OR t.tieu_de ILIKE '%' || $10::text || '%'
    )
    -- Filter theo phương thức thanh toán
    AND (
        $11::text IS NULL 
        OR $11::text = ''
        OR dc.phuong_thuc_thanh_toan::text = $11::text
    )
    -- Filter theo khoảng giá
    AND ($12::numeric IS NULL OR dc.tong_tien >= $12::numeric)
    AND ($13::numeric IS NULL OR dc.tong_tien <= $13::numeric)
ORDER BY 
    CASE WHEN $14::text = 'ngay_dat_asc' THEN dc.ngay_dat END ASC,
    CASE WHEN $14::text = 'ngay_dat_desc' THEN dc.ngay_dat END DESC,
    CASE WHEN $14::text = 'tong_tien_asc' THEN dc.tong_tien END ASC,
    CASE WHEN $14::text = 'tong_tien_desc' THEN dc.tong_tien END DESC,
    CASE WHEN $14::text = 'ngay_khoi_hanh_asc' THEN kh.ngay_khoi_hanh END ASC,
    CASE WHEN $14::text = 'ngay_khoi_hanh_desc' THEN kh.ngay_khoi_hanh END DESC,
    dc.ngay_dat DESC
LIMIT $2 OFFSET $3
`

type GetSupplierBookingsByStatusAdvancedParams struct {
	ID                  pgtype.UUID      `json:"id"`
	Limit               int32            `json:"limit"`
	Offset              int32            `json:"offset"`
	TrangThai           *string          `json:"trang_thai"`
	TourID              *int32           `json:"tour_id"`
	StartDate           pgtype.Timestamp `json:"start_date"`
	EndDate             pgtype.Timestamp `json:"end_date"`
	DepartureStartDate  pgtype.Date      `json:"departure_start_date"`
	DepartureEndDate    pgtype.Date      `json:"departure_end_date"`
	SearchKeyword       *string          `json:"search_keyword"`
	PhuongThucThanhToan *string          `json:"phuong_thuc_thanh_toan"`
	MinAmount           pgtype.Numeric   `json:"min_amount"`
	MaxAmount           pgtype.Numeric   `json:"max_amount"`
	SortBy              *string          `json:"sort_by"`
}

type GetSupplierBookingsByStatusAdvancedRow struct {
	BookingID           int32                 `json:"booking_id"`
	NgayDat             pgtype.Timestamp      `json:"ngay_dat"`
	TrangThai           NullTrangThaiDatCho   `json:"trang_thai"`
	TongTien            pgtype.Numeric        `json:"tong_tien"`
	DonViTienTe         *string               `json:"don_vi_tien_te"`
	SoNguoiLon          *int32                `json:"so_nguoi_lon"`
	SoTreEm             *int32                `json:"so_tre_em"`
	PhuongThucThanhToan *string               `json:"phuong_thuc_thanh_toan"`
	NgayCapNhat         pgtype.Timestamp      `json:"ngay_cap_nhat"`
	CustomerID          pgtype.UUID           `json:"customer_id"`
	CustomerName        string                `json:"customer_name"`
	CustomerEmail       string                `json:"customer_email"`
	CustomerPhone       *string               `json:"customer_phone"`
	TourID              int32                 `json:"tour_id"`
	TourTitle           string                `json:"tour_title"`
	TourPriceAdult      pgtype.Numeric        `json:"tour_price_adult"`
	TourPriceChild      pgtype.Numeric        `json:"tour_price_child"`
	TourCurrency        *string               `json:"tour_currency"`
	TourImage           string                `json:"tour_image"`
	DepartureID         int32                 `json:"departure_id"`
	NgayKhoiHanh        pgtype.Date           `json:"ngay_khoi_hanh"`
	NgayKetThuc         pgtype.Date           `json:"ngay_ket_thuc"`
	DepartureCapacity   int32                 `json:"departure_capacity"`
	DepartureBooked     *int32                `json:"departure_booked"`
	DepartureAvailable  int32                 `json:"departure_available"`
	DepartureStatus     NullTrangThaiKhoiHanh `json:"departure_status"`
	PassengerCount      int32                 `json:"passenger_count"`
	SuccessfulPayments  int32                 `json:"successful_payments"`
	TotalPassengers     int32                 `json:"total_passengers"`
	ConfirmedRevenue    pgtype.Numeric        `json:"confirmed_revenue"`
}

// Lấy danh sách đặt chỗ theo trạng thái với nhiều filter nâng cao
func (q *Queries) GetSupplierBookingsByStatusAdvanced(ctx context.Context, arg GetSupplierBookingsByStatusAdvancedParams) ([]GetSupplierBookingsByStatusAdvancedRow, error) {
	rows, err := q.db.Query(ctx, getSupplierBookingsByStatusAdvanced,
		arg.ID,
		arg.Limit,
		arg.Offset,
		arg.TrangThai,
		arg.TourID,
		arg.StartDate,
		arg.EndDate,
		arg.DepartureStartDate,
		arg.DepartureEndDate,
		arg.SearchKeyword,
		arg.PhuongThucThanhToan,
		arg.MinAmount,
		arg.MaxAmount,
		arg.SortBy,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetSupplierBookingsByStatusAdvancedRow
	for rows.Next() {
		var i GetSupplierBookingsByStatusAdvancedRow
		if err := rows.Scan(
			&i.BookingID,
			&i.NgayDat,
			&i.TrangThai,
			&i.TongTien,
			&i.DonViTienTe,
			&i.SoNguoiLon,
			&i.SoTreEm,
			&i.PhuongThucThanhToan,
			&i.NgayCapNhat,
			&i.CustomerID,
			&i.CustomerName,
			&i.CustomerEmail,
			&i.CustomerPhone,
			&i.TourID,
			&i.TourTitle,
			&i.TourPriceAdult,
			&i.TourPriceChild,
			&i.TourCurrency,
			&i.TourImage,
			&i.DepartureID,
			&i.NgayKhoiHanh,
			&i.NgayKetThuc,
			&i.DepartureCapacity,
			&i.DepartureBooked,
			&i.DepartureAvailable,
			&i.DepartureStatus,
			&i.PassengerCount,
			&i.SuccessfulPayments,
			&i.TotalPassengers,
			&i.ConfirmedRevenue,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSupplierByID = `-- name: GetSupplierByID :one
SELECT nha_cung_cap.id, nha_cung_cap.ten, nha_cung_cap.dia_chi, nha_cung_cap.website, nha_cung_cap.mo_ta, nha_cung_cap.logo, nha_cung_cap.nam_thanh_lap, nha_cung_cap.thanh_pho, nha_cung_cap.quoc_gia, nha_cung_cap.ma_so_thue, nha_cung_cap.so_nhan_vien, nha_cung_cap.giay_to_kinh_doanh, nguoi_dung.ho_ten, nguoi_dung.email, nguoi_dung.so_dien_thoai, nguoi_dung.ngay_tao, nguoi_dung.ngay_cap_nhat FROM nha_cung_cap
JOIN nguoi_dung ON nguoi_dung.id = nha_cung_cap.id
WHERE nha_cung_cap.id = $1 AND nguoi_dung.dang_hoat_dong = TRUE
`

type GetSupplierByIDRow struct {
	ID              pgtype.UUID      `json:"id"`
	Ten             string           `json:"ten"`
	DiaChi          *string          `json:"dia_chi"`
	Website         *string          `json:"website"`
	MoTa            *string          `json:"mo_ta"`
	Logo            *string          `json:"logo"`
	NamThanhLap     pgtype.Date      `json:"nam_thanh_lap"`
	ThanhPho        *string          `json:"thanh_pho"`
	QuocGia         *string          `json:"quoc_gia"`
	MaSoThue        *string          `json:"ma_so_thue"`
	SoNhanVien      *string          `json:"so_nhan_vien"`
	GiayToKinhDoanh *string          `json:"giay_to_kinh_doanh"`
	HoTen           string           `json:"ho_ten"`
	Email           string           `json:"email"`
	SoDienThoai     *string          `json:"so_dien_thoai"`
	NgayTao         pgtype.Timestamp `json:"ngay_tao"`
	NgayCapNhat     pgtype.Timestamp `json:"ngay_cap_nhat"`
}

func (q *Queries) GetSupplierByID(ctx context.Context, id pgtype.UUID) (GetSupplierByIDRow, error) {
	row := q.db.QueryRow(ctx, getSupplierByID, id)
	var i GetSupplierByIDRow
	err := row.Scan(
		&i.ID,
		&i.Ten,
		&i.DiaChi,
		&i.Website,
		&i.MoTa,
		&i.Logo,
		&i.NamThanhLap,
		&i.ThanhPho,
		&i.QuocGia,
		&i.MaSoThue,
		&i.SoNhanVien,
		&i.GiayToKinhDoanh,
		&i.HoTen,
		&i.Email,
		&i.SoDienThoai,
		&i.NgayTao,
		&i.NgayCapNhat,
	)
	return i, err
}

const getSupplierById = `-- name: GetSupplierById :one
SELECT nha_cung_cap.id, nha_cung_cap.ten, nha_cung_cap.dia_chi, nha_cung_cap.website, nha_cung_cap.mo_ta, nha_cung_cap.logo, nha_cung_cap.nam_thanh_lap, nha_cung_cap.thanh_pho, nha_cung_cap.quoc_gia, nha_cung_cap.ma_so_thue, nha_cung_cap.so_nhan_vien, nha_cung_cap.giay_to_kinh_doanh, nguoi_dung.ho_ten, nguoi_dung.email, nguoi_dung.so_dien_thoai, nguoi_dung.ngay_tao, nguoi_dung.ngay_cap_nhat FROM nha_cung_cap
JOIN nguoi_dung ON nguoi_dung.id = nha_cung_cap.id
WHERE nha_cung_cap.id = $1 AND nguoi_dung.dang_hoat_dong = TRUE
`

type GetSupplierByIdRow struct {
	ID              pgtype.UUID      `json:"id"`
	Ten             string           `json:"ten"`
	DiaChi          *string          `json:"dia_chi"`
	Website         *string          `json:"website"`
	MoTa            *string          `json:"mo_ta"`
	Logo            *string          `json:"logo"`
	NamThanhLap     pgtype.Date      `json:"nam_thanh_lap"`
	ThanhPho        *string          `json:"thanh_pho"`
	QuocGia         *string          `json:"quoc_gia"`
	MaSoThue        *string          `json:"ma_so_thue"`
	SoNhanVien      *string          `json:"so_nhan_vien"`
	GiayToKinhDoanh *string          `json:"giay_to_kinh_doanh"`
	HoTen           string           `json:"ho_ten"`
	Email           string           `json:"email"`
	SoDienThoai     *string          `json:"so_dien_thoai"`
	NgayTao         pgtype.Timestamp `json:"ngay_tao"`
	NgayCapNhat     pgtype.Timestamp `json:"ngay_cap_nhat"`
}

func (q *Queries) GetSupplierById(ctx context.Context, id pgtype.UUID) (GetSupplierByIdRow, error) {
	row := q.db.QueryRow(ctx, getSupplierById, id)
	var i GetSupplierByIdRow
	err := row.Scan(
		&i.ID,
		&i.Ten,
		&i.DiaChi,
		&i.Website,
		&i.MoTa,
		&i.Logo,
		&i.NamThanhLap,
		&i.ThanhPho,
		&i.QuocGia,
		&i.MaSoThue,
		&i.SoNhanVien,
		&i.GiayToKinhDoanh,
		&i.HoTen,
		&i.Email,
		&i.SoDienThoai,
		&i.NgayTao,
		&i.NgayCapNhat,
	)
	return i, err
}

const getSupplierCancellationAnalysis = `-- name: GetSupplierCancellationAnalysis :one
SELECT 
    COUNT(DISTINCT dc.id)::int AS total_bookings,
    COUNT(DISTINCT CASE WHEN dc.trang_thai = 'da_huy' THEN dc.id END)::int AS cancelled_bookings,
    CASE 
        WHEN COUNT(DISTINCT dc.id) > 0 THEN 
            (COUNT(DISTINCT CASE WHEN dc.trang_thai = 'da_huy' THEN dc.id END)::float / COUNT(DISTINCT dc.id)::float * 100)
        ELSE 0 
    END::float AS cancellation_rate,
    COALESCE(SUM(dc.tong_tien) FILTER (WHERE dc.trang_thai = 'da_huy'), 0)::numeric AS lost_revenue,
    COUNT(DISTINCT CASE WHEN dc.trang_thai = 'da_huy' AND dc.ngay_dat >= CURRENT_DATE - INTERVAL '30 days' THEN dc.id END)::int AS cancelled_last_30_days
FROM nha_cung_cap ncc
JOIN tour t ON t.nha_cung_cap_id = ncc.id AND t.dang_hoat_dong = TRUE
JOIN khoi_hanh_tour kh ON kh.tour_id = t.id
JOIN dat_cho dc ON dc.khoi_hanh_id = kh.id
WHERE ncc.id = $1
    AND ($2::timestamp IS NULL OR dc.ngay_dat >= $2)
    AND ($3::timestamp IS NULL OR dc.ngay_dat <= $3)
`

type GetSupplierCancellationAnalysisParams struct {
	ID      pgtype.UUID      `json:"id"`
	Column2 pgtype.Timestamp `json:"column_2"`
	Column3 pgtype.Timestamp `json:"column_3"`
}

type GetSupplierCancellationAnalysisRow struct {
	TotalBookings       int32          `json:"total_bookings"`
	CancelledBookings   int32          `json:"cancelled_bookings"`
	CancellationRate    float64        `json:"cancellation_rate"`
	LostRevenue         pgtype.Numeric `json:"lost_revenue"`
	CancelledLast30Days int32          `json:"cancelled_last_30_days"`
}

// Phân tích tỷ lệ hủy booking
func (q *Queries) GetSupplierCancellationAnalysis(ctx context.Context, arg GetSupplierCancellationAnalysisParams) (GetSupplierCancellationAnalysisRow, error) {
	row := q.db.QueryRow(ctx, getSupplierCancellationAnalysis, arg.ID, arg.Column2, arg.Column3)
	var i GetSupplierCancellationAnalysisRow
	err := row.Scan(
		&i.TotalBookings,
		&i.CancelledBookings,
		&i.CancellationRate,
		&i.LostRevenue,
		&i.CancelledLast30Days,
	)
	return i, err
}

const getSupplierCustomerStats = `-- name: GetSupplierCustomerStats :many
SELECT 
    nd.id AS customer_id,
    nd.ho_ten AS customer_name,
    nd.email AS customer_email,
    COUNT(DISTINCT dc.id)::int AS total_bookings,
    COALESCE(SUM(dc.tong_tien) FILTER (WHERE dc.trang_thai IN ('da_thanh_toan', 'hoan_thanh')), 0)::numeric AS total_spent,
    COALESCE(SUM(dc.so_nguoi_lon + dc.so_tre_em) FILTER (WHERE dc.trang_thai IN ('da_thanh_toan', 'hoan_thanh')), 0)::int AS total_passengers,
    MIN(dc.ngay_dat)::timestamp AS first_booking_date,
    MAX(dc.ngay_dat)::timestamp AS last_booking_date
FROM nha_cung_cap ncc
JOIN tour t ON t.nha_cung_cap_id = ncc.id AND t.dang_hoat_dong = TRUE
JOIN khoi_hanh_tour kh ON kh.tour_id = t.id
JOIN dat_cho dc ON dc.khoi_hanh_id = kh.id
JOIN nguoi_dung nd ON nd.id = dc.nguoi_dung_id
WHERE ncc.id = $1
    AND ($2::timestamp IS NULL OR dc.ngay_dat >= $2)
    AND ($3::timestamp IS NULL OR dc.ngay_dat <= $3)
GROUP BY nd.id, nd.ho_ten, nd.email
ORDER BY 
    CASE WHEN $4::text = 'spent' THEN COALESCE(SUM(dc.tong_tien) FILTER (WHERE dc.trang_thai IN ('da_thanh_toan', 'hoan_thanh')), 0) END DESC,
    CASE WHEN $4::text = 'bookings' THEN COUNT(DISTINCT dc.id) END DESC,
    total_spent DESC
LIMIT $5
`

type GetSupplierCustomerStatsParams struct {
	ID      pgtype.UUID      `json:"id"`
	Column2 pgtype.Timestamp `json:"column_2"`
	Column3 pgtype.Timestamp `json:"column_3"`
	Column4 string           `json:"column_4"`
	Limit   int32            `json:"limit"`
}

type GetSupplierCustomerStatsRow struct {
	CustomerID       pgtype.UUID      `json:"customer_id"`
	CustomerName     string           `json:"customer_name"`
	CustomerEmail    string           `json:"customer_email"`
	TotalBookings    int32            `json:"total_bookings"`
	TotalSpent       pgtype.Numeric   `json:"total_spent"`
	TotalPassengers  int32            `json:"total_passengers"`
	FirstBookingDate pgtype.Timestamp `json:"first_booking_date"`
	LastBookingDate  pgtype.Timestamp `json:"last_booking_date"`
}

// Thống kê khách hàng: top khách hàng, số lần đặt, tổng tiền
func (q *Queries) GetSupplierCustomerStats(ctx context.Context, arg GetSupplierCustomerStatsParams) ([]GetSupplierCustomerStatsRow, error) {
	rows, err := q.db.Query(ctx, getSupplierCustomerStats,
		arg.ID,
		arg.Column2,
		arg.Column3,
		arg.Column4,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetSupplierCustomerStatsRow
	for rows.Next() {
		var i GetSupplierCustomerStatsRow
		if err := rows.Scan(
			&i.CustomerID,
			&i.CustomerName,
			&i.CustomerEmail,
			&i.TotalBookings,
			&i.TotalSpent,
			&i.TotalPassengers,
			&i.FirstBookingDate,
			&i.LastBookingDate,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSupplierDashboardOverview = `-- name: GetSupplierDashboardOverview :one

SELECT 
    -- Tổng số tour
    COUNT(DISTINCT t.id)::int AS total_tours,
    COUNT(DISTINCT CASE WHEN t.trang_thai = 'cong_bo' THEN t.id END)::int AS published_tours,
    COUNT(DISTINCT CASE WHEN t.trang_thai = 'nhap' THEN t.id END)::int AS draft_tours,
    COUNT(DISTINCT CASE WHEN t.trang_thai = 'luu_tru' THEN t.id END)::int AS archived_tours,
    
    -- Tổng số booking
    COUNT(DISTINCT dc.id)::int AS total_bookings,
    COUNT(DISTINCT CASE WHEN dc.trang_thai = 'cho_xac_nhan' THEN dc.id END)::int AS pending_bookings,
    COUNT(DISTINCT CASE WHEN dc.trang_thai = 'da_xac_nhan' THEN dc.id END)::int AS confirmed_bookings,
    COUNT(DISTINCT CASE WHEN dc.trang_thai = 'da_thanh_toan' THEN dc.id END)::int AS paid_bookings,
    COUNT(DISTINCT CASE WHEN dc.trang_thai = 'hoan_thanh' THEN dc.id END)::int AS completed_bookings,
    COUNT(DISTINCT CASE WHEN dc.trang_thai = 'da_huy' THEN dc.id END)::int AS cancelled_bookings,
    
    -- Doanh thu
    COALESCE(SUM(dc.tong_tien) FILTER (WHERE dc.trang_thai IN ('da_thanh_toan', 'hoan_thanh')), 0)::numeric AS total_revenue,
    COALESCE(SUM(dc.tong_tien) FILTER (WHERE dc.trang_thai IN ('da_thanh_toan', 'hoan_thanh') AND dc.ngay_dat >= CURRENT_DATE - INTERVAL '30 days'), 0)::numeric AS revenue_last_30_days,
    COALESCE(SUM(dc.tong_tien) FILTER (WHERE dc.trang_thai IN ('da_thanh_toan', 'hoan_thanh') AND dc.ngay_dat >= CURRENT_DATE - INTERVAL '7 days'), 0)::numeric AS revenue_last_7_days,
    
    -- Đánh giá
    COALESCE(AVG(dg.diem_danh_gia), 0)::float AS avg_rating,
    COUNT(DISTINCT dg.id)::int AS total_reviews,
    
    -- Khách hàng
    COUNT(DISTINCT dc.nguoi_dung_id)::int AS total_customers,
    
    -- Tỷ lệ hủy
    CASE 
        WHEN COUNT(DISTINCT dc.id) > 0 THEN 
            (COUNT(DISTINCT CASE WHEN dc.trang_thai = 'da_huy' THEN dc.id END)::float / COUNT(DISTINCT dc.id)::float * 100)
        ELSE 0 
    END::float AS cancellation_rate
FROM nha_cung_cap ncc
LEFT JOIN tour t ON t.nha_cung_cap_id = ncc.id AND t.dang_hoat_dong = TRUE
LEFT JOIN khoi_hanh_tour kh ON kh.tour_id = t.id
LEFT JOIN dat_cho dc ON dc.khoi_hanh_id = kh.id
LEFT JOIN danh_gia dg ON dg.tour_id = t.id AND dg.dang_hoat_dong = TRUE
WHERE ncc.id = $1
`

type GetSupplierDashboardOverviewRow struct {
	TotalTours        int32          `json:"total_tours"`
	PublishedTours    int32          `json:"published_tours"`
	DraftTours        int32          `json:"draft_tours"`
	ArchivedTours     int32          `json:"archived_tours"`
	TotalBookings     int32          `json:"total_bookings"`
	PendingBookings   int32          `json:"pending_bookings"`
	ConfirmedBookings int32          `json:"confirmed_bookings"`
	PaidBookings      int32          `json:"paid_bookings"`
	CompletedBookings int32          `json:"completed_bookings"`
	CancelledBookings int32          `json:"cancelled_bookings"`
	TotalRevenue      pgtype.Numeric `json:"total_revenue"`
	RevenueLast30Days pgtype.Numeric `json:"revenue_last_30_days"`
	RevenueLast7Days  pgtype.Numeric `json:"revenue_last_7_days"`
	AvgRating         float64        `json:"avg_rating"`
	TotalReviews      int32          `json:"total_reviews"`
	TotalCustomers    int32          `json:"total_customers"`
	CancellationRate  float64        `json:"cancellation_rate"`
}

// ===========================================
// DASHBOARD SUPPLIER - TRUY VẤN NÂNG CAO
// ===========================================
// Tổng quan dashboard: tổng doanh thu, số booking, số tour, đánh giá trung bình
func (q *Queries) GetSupplierDashboardOverview(ctx context.Context, id pgtype.UUID) (GetSupplierDashboardOverviewRow, error) {
	row := q.db.QueryRow(ctx, getSupplierDashboardOverview, id)
	var i GetSupplierDashboardOverviewRow
	err := row.Scan(
		&i.TotalTours,
		&i.PublishedTours,
		&i.DraftTours,
		&i.ArchivedTours,
		&i.TotalBookings,
		&i.PendingBookings,
		&i.ConfirmedBookings,
		&i.PaidBookings,
		&i.CompletedBookings,
		&i.CancelledBookings,
		&i.TotalRevenue,
		&i.RevenueLast30Days,
		&i.RevenueLast7Days,
		&i.AvgRating,
		&i.TotalReviews,
		&i.TotalCustomers,
		&i.CancellationRate,
	)
	return i, err
}

const getSupplierMonthlyComparison = `-- name: GetSupplierMonthlyComparison :one
SELECT 
    -- Tháng hiện tại
    COUNT(DISTINCT dc.id) FILTER (WHERE DATE_TRUNC('month', dc.ngay_dat) = DATE_TRUNC('month', CURRENT_DATE))::int AS current_month_bookings,
    COALESCE(SUM(dc.tong_tien) FILTER (WHERE dc.trang_thai IN ('da_thanh_toan', 'hoan_thanh') AND DATE_TRUNC('month', dc.ngay_dat) = DATE_TRUNC('month', CURRENT_DATE)), 0)::numeric AS current_month_revenue,
    
    -- Tháng trước
    COUNT(DISTINCT dc.id) FILTER (WHERE DATE_TRUNC('month', dc.ngay_dat) = DATE_TRUNC('month', CURRENT_DATE - INTERVAL '1 month'))::int AS previous_month_bookings,
    COALESCE(SUM(dc.tong_tien) FILTER (WHERE dc.trang_thai IN ('da_thanh_toan', 'hoan_thanh') AND DATE_TRUNC('month', dc.ngay_dat) = DATE_TRUNC('month', CURRENT_DATE - INTERVAL '1 month')), 0)::numeric AS previous_month_revenue,
    
    -- Tính phần trăm thay đổi
    CASE 
        WHEN COUNT(DISTINCT dc.id) FILTER (WHERE DATE_TRUNC('month', dc.ngay_dat) = DATE_TRUNC('month', CURRENT_DATE - INTERVAL '1 month')) > 0 THEN
            ((COUNT(DISTINCT dc.id) FILTER (WHERE DATE_TRUNC('month', dc.ngay_dat) = DATE_TRUNC('month', CURRENT_DATE))::float - 
              COUNT(DISTINCT dc.id) FILTER (WHERE DATE_TRUNC('month', dc.ngay_dat) = DATE_TRUNC('month', CURRENT_DATE - INTERVAL '1 month'))::float) /
             COUNT(DISTINCT dc.id) FILTER (WHERE DATE_TRUNC('month', dc.ngay_dat) = DATE_TRUNC('month', CURRENT_DATE - INTERVAL '1 month'))::float * 100)
        ELSE 0
    END::float AS booking_change_percent,
    
    CASE 
        WHEN COALESCE(SUM(dc.tong_tien) FILTER (WHERE dc.trang_thai IN ('da_thanh_toan', 'hoan_thanh') AND DATE_TRUNC('month', dc.ngay_dat) = DATE_TRUNC('month', CURRENT_DATE - INTERVAL '1 month')), 0) > 0 THEN
            ((COALESCE(SUM(dc.tong_tien) FILTER (WHERE dc.trang_thai IN ('da_thanh_toan', 'hoan_thanh') AND DATE_TRUNC('month', dc.ngay_dat) = DATE_TRUNC('month', CURRENT_DATE)), 0)::float - 
              COALESCE(SUM(dc.tong_tien) FILTER (WHERE dc.trang_thai IN ('da_thanh_toan', 'hoan_thanh') AND DATE_TRUNC('month', dc.ngay_dat) = DATE_TRUNC('month', CURRENT_DATE - INTERVAL '1 month')), 0)::float) /
             COALESCE(SUM(dc.tong_tien) FILTER (WHERE dc.trang_thai IN ('da_thanh_toan', 'hoan_thanh') AND DATE_TRUNC('month', dc.ngay_dat) = DATE_TRUNC('month', CURRENT_DATE - INTERVAL '1 month')), 0)::float * 100)
        ELSE 0
    END::float AS revenue_change_percent
FROM nha_cung_cap ncc
JOIN tour t ON t.nha_cung_cap_id = ncc.id AND t.dang_hoat_dong = TRUE
JOIN khoi_hanh_tour kh ON kh.tour_id = t.id
JOIN dat_cho dc ON dc.khoi_hanh_id = kh.id
WHERE ncc.id = $1
`

type GetSupplierMonthlyComparisonRow struct {
	CurrentMonthBookings  int32          `json:"current_month_bookings"`
	CurrentMonthRevenue   pgtype.Numeric `json:"current_month_revenue"`
	PreviousMonthBookings int32          `json:"previous_month_bookings"`
	PreviousMonthRevenue  pgtype.Numeric `json:"previous_month_revenue"`
	BookingChangePercent  float64        `json:"booking_change_percent"`
	RevenueChangePercent  float64        `json:"revenue_change_percent"`
}

// So sánh tháng hiện tại với tháng trước
func (q *Queries) GetSupplierMonthlyComparison(ctx context.Context, id pgtype.UUID) (GetSupplierMonthlyComparisonRow, error) {
	row := q.db.QueryRow(ctx, getSupplierMonthlyComparison, id)
	var i GetSupplierMonthlyComparisonRow
	err := row.Scan(
		&i.CurrentMonthBookings,
		&i.CurrentMonthRevenue,
		&i.PreviousMonthBookings,
		&i.PreviousMonthRevenue,
		&i.BookingChangePercent,
		&i.RevenueChangePercent,
	)
	return i, err
}

const getSupplierRatingAnalysis = `-- name: GetSupplierRatingAnalysis :one
SELECT 
    COUNT(DISTINCT dg.id)::int AS total_reviews,
    COALESCE(AVG(dg.diem_danh_gia), 0)::float AS avg_rating,
    COUNT(DISTINCT CASE WHEN dg.diem_danh_gia = 5 THEN dg.id END)::int AS five_star_count,
    COUNT(DISTINCT CASE WHEN dg.diem_danh_gia = 4 THEN dg.id END)::int AS four_star_count,
    COUNT(DISTINCT CASE WHEN dg.diem_danh_gia = 3 THEN dg.id END)::int AS three_star_count,
    COUNT(DISTINCT CASE WHEN dg.diem_danh_gia = 2 THEN dg.id END)::int AS two_star_count,
    COUNT(DISTINCT CASE WHEN dg.diem_danh_gia = 1 THEN dg.id END)::int AS one_star_count,
    COUNT(DISTINCT t.id)::int AS tours_with_reviews
FROM nha_cung_cap ncc
JOIN tour t ON t.nha_cung_cap_id = ncc.id AND t.dang_hoat_dong = TRUE
LEFT JOIN danh_gia dg ON dg.tour_id = t.id AND dg.dang_hoat_dong = TRUE
WHERE ncc.id = $1
`

type GetSupplierRatingAnalysisRow struct {
	TotalReviews     int32   `json:"total_reviews"`
	AvgRating        float64 `json:"avg_rating"`
	FiveStarCount    int32   `json:"five_star_count"`
	FourStarCount    int32   `json:"four_star_count"`
	ThreeStarCount   int32   `json:"three_star_count"`
	TwoStarCount     int32   `json:"two_star_count"`
	OneStarCount     int32   `json:"one_star_count"`
	ToursWithReviews int32   `json:"tours_with_reviews"`
}

// Phân tích đánh giá tour
func (q *Queries) GetSupplierRatingAnalysis(ctx context.Context, id pgtype.UUID) (GetSupplierRatingAnalysisRow, error) {
	row := q.db.QueryRow(ctx, getSupplierRatingAnalysis, id)
	var i GetSupplierRatingAnalysisRow
	err := row.Scan(
		&i.TotalReviews,
		&i.AvgRating,
		&i.FiveStarCount,
		&i.FourStarCount,
		&i.ThreeStarCount,
		&i.TwoStarCount,
		&i.OneStarCount,
		&i.ToursWithReviews,
	)
	return i, err
}

const getSupplierRecentBookings = `-- name: GetSupplierRecentBookings :many
SELECT 
    dc.id AS booking_id,
    dc.ngay_dat,
    dc.trang_thai,
    dc.tong_tien,
    dc.don_vi_tien_te,
    dc.so_nguoi_lon,
    dc.so_tre_em,
    nd.ho_ten AS customer_name,
    nd.email AS customer_email,
    t.id AS tour_id,
    t.tieu_de AS tour_title,
    kh.ngay_khoi_hanh
FROM nha_cung_cap ncc
JOIN tour t ON t.nha_cung_cap_id = ncc.id AND t.dang_hoat_dong = TRUE
JOIN khoi_hanh_tour kh ON kh.tour_id = t.id
JOIN dat_cho dc ON dc.khoi_hanh_id = kh.id
JOIN nguoi_dung nd ON nd.id = dc.nguoi_dung_id
WHERE ncc.id = $1
ORDER BY dc.ngay_dat DESC
LIMIT $2
`

type GetSupplierRecentBookingsParams struct {
	ID    pgtype.UUID `json:"id"`
	Limit int32       `json:"limit"`
}

type GetSupplierRecentBookingsRow struct {
	BookingID     int32               `json:"booking_id"`
	NgayDat       pgtype.Timestamp    `json:"ngay_dat"`
	TrangThai     NullTrangThaiDatCho `json:"trang_thai"`
	TongTien      pgtype.Numeric      `json:"tong_tien"`
	DonViTienTe   *string             `json:"don_vi_tien_te"`
	SoNguoiLon    *int32              `json:"so_nguoi_lon"`
	SoTreEm       *int32              `json:"so_tre_em"`
	CustomerName  string              `json:"customer_name"`
	CustomerEmail string              `json:"customer_email"`
	TourID        int32               `json:"tour_id"`
	TourTitle     string              `json:"tour_title"`
	NgayKhoiHanh  pgtype.Date         `json:"ngay_khoi_hanh"`
}

// Booking gần đây
func (q *Queries) GetSupplierRecentBookings(ctx context.Context, arg GetSupplierRecentBookingsParams) ([]GetSupplierRecentBookingsRow, error) {
	rows, err := q.db.Query(ctx, getSupplierRecentBookings, arg.ID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetSupplierRecentBookingsRow
	for rows.Next() {
		var i GetSupplierRecentBookingsRow
		if err := rows.Scan(
			&i.BookingID,
			&i.NgayDat,
			&i.TrangThai,
			&i.TongTien,
			&i.DonViTienTe,
			&i.SoNguoiLon,
			&i.SoTreEm,
			&i.CustomerName,
			&i.CustomerEmail,
			&i.TourID,
			&i.TourTitle,
			&i.NgayKhoiHanh,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSupplierRevenueByTimeRange = `-- name: GetSupplierRevenueByTimeRange :many
SELECT 
    DATE_TRUNC($2::text, dc.ngay_dat)::timestamp AS period,
    COUNT(DISTINCT dc.id)::int AS booking_count,
    COALESCE(SUM(dc.tong_tien) FILTER (WHERE dc.trang_thai IN ('da_thanh_toan', 'hoan_thanh')), 0)::numeric AS revenue,
    COALESCE(SUM(dc.so_nguoi_lon + dc.so_tre_em) FILTER (WHERE dc.trang_thai IN ('da_thanh_toan', 'hoan_thanh')), 0)::int AS total_passengers
FROM nha_cung_cap ncc
JOIN tour t ON t.nha_cung_cap_id = ncc.id AND t.dang_hoat_dong = TRUE
JOIN khoi_hanh_tour kh ON kh.tour_id = t.id
JOIN dat_cho dc ON dc.khoi_hanh_id = kh.id
WHERE ncc.id = $1
    AND dc.ngay_dat >= COALESCE($3::timestamp, CURRENT_DATE - INTERVAL '30 days')
    AND dc.ngay_dat <= COALESCE($4::timestamp, CURRENT_DATE)
    AND dc.trang_thai IN ('da_thanh_toan', 'hoan_thanh', 'cho_xac_nhan', 'da_xac_nhan')
GROUP BY DATE_TRUNC($2::text, dc.ngay_dat)
ORDER BY period ASC
`

type GetSupplierRevenueByTimeRangeParams struct {
	ID      pgtype.UUID      `json:"id"`
	Column2 string           `json:"column_2"`
	Column3 pgtype.Timestamp `json:"column_3"`
	Column4 pgtype.Timestamp `json:"column_4"`
}

type GetSupplierRevenueByTimeRangeRow struct {
	Period          pgtype.Timestamp `json:"period"`
	BookingCount    int32            `json:"booking_count"`
	Revenue         pgtype.Numeric   `json:"revenue"`
	TotalPassengers int32            `json:"total_passengers"`
}

// Doanh thu theo khoảng thời gian (ngày, tuần, tháng)
func (q *Queries) GetSupplierRevenueByTimeRange(ctx context.Context, arg GetSupplierRevenueByTimeRangeParams) ([]GetSupplierRevenueByTimeRangeRow, error) {
	rows, err := q.db.Query(ctx, getSupplierRevenueByTimeRange,
		arg.ID,
		arg.Column2,
		arg.Column3,
		arg.Column4,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetSupplierRevenueByTimeRangeRow
	for rows.Next() {
		var i GetSupplierRevenueByTimeRangeRow
		if err := rows.Scan(
			&i.Period,
			&i.BookingCount,
			&i.Revenue,
			&i.TotalPassengers,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSupplierRevenueChart = `-- name: GetSupplierRevenueChart :many
SELECT 
    DATE_TRUNC($2::text, dc.ngay_dat) AS date,
    COALESCE(SUM(dc.tong_tien) FILTER (WHERE dc.trang_thai IN ('da_thanh_toan', 'hoan_thanh')), 0)::numeric AS revenue,
    COUNT(DISTINCT dc.id) FILTER (WHERE dc.trang_thai IN ('da_thanh_toan', 'hoan_thanh'))::int AS booking_count,
    COUNT(DISTINCT dc.nguoi_dung_id) FILTER (WHERE dc.trang_thai IN ('da_thanh_toan', 'hoan_thanh'))::int AS customer_count
FROM nha_cung_cap ncc
JOIN tour t ON t.nha_cung_cap_id = ncc.id AND t.dang_hoat_dong = TRUE
JOIN khoi_hanh_tour kh ON kh.tour_id = t.id
JOIN dat_cho dc ON dc.khoi_hanh_id = kh.id
WHERE ncc.id = $1
    AND dc.ngay_dat >= COALESCE($3::timestamp, CURRENT_DATE - INTERVAL '30 days')
    AND dc.ngay_dat <= COALESCE($4::timestamp, CURRENT_DATE)
    AND dc.trang_thai IN ('da_thanh_toan', 'hoan_thanh')
GROUP BY DATE_TRUNC($2::text, dc.ngay_dat)
ORDER BY date ASC
`

type GetSupplierRevenueChartParams struct {
	ID      pgtype.UUID      `json:"id"`
	Column2 string           `json:"column_2"`
	Column3 pgtype.Timestamp `json:"column_3"`
	Column4 pgtype.Timestamp `json:"column_4"`
}

type GetSupplierRevenueChartRow struct {
	Date          pgtype.Interval `json:"date"`
	Revenue       pgtype.Numeric  `json:"revenue"`
	BookingCount  int32           `json:"booking_count"`
	CustomerCount int32           `json:"customer_count"`
}

// Biểu đồ doanh thu theo thời gian (cho chart)
func (q *Queries) GetSupplierRevenueChart(ctx context.Context, arg GetSupplierRevenueChartParams) ([]GetSupplierRevenueChartRow, error) {
	rows, err := q.db.Query(ctx, getSupplierRevenueChart,
		arg.ID,
		arg.Column2,
		arg.Column3,
		arg.Column4,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetSupplierRevenueChartRow
	for rows.Next() {
		var i GetSupplierRevenueChartRow
		if err := rows.Scan(
			&i.Date,
			&i.Revenue,
			&i.BookingCount,
			&i.CustomerCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSupplierTopTours = `-- name: GetSupplierTopTours :many
SELECT 
    t.id,
    t.tieu_de,
    t.gia_nguoi_lon,
    t.gia_tre_em,
    t.don_vi_tien_te,
    t.trang_thai,
    (
        SELECT a.duong_dan
        FROM anh_tour a
        WHERE a.tour_id = t.id AND a.la_anh_chinh = TRUE
        LIMIT 1
    ) AS anh_chinh,
    COUNT(DISTINCT dc.id)::int AS total_bookings,
    COALESCE(SUM(dc.tong_tien) FILTER (WHERE dc.trang_thai IN ('da_thanh_toan', 'hoan_thanh')), 0)::numeric AS total_revenue,
    COALESCE(SUM(dc.so_nguoi_lon + dc.so_tre_em) FILTER (WHERE dc.trang_thai IN ('da_thanh_toan', 'hoan_thanh')), 0)::int AS total_passengers,
    COALESCE(AVG(dg.diem_danh_gia), 0)::float AS avg_rating,
    COUNT(DISTINCT dg.id)::int AS total_reviews
FROM nha_cung_cap ncc
JOIN tour t ON t.nha_cung_cap_id = ncc.id AND t.dang_hoat_dong = TRUE
LEFT JOIN khoi_hanh_tour kh ON kh.tour_id = t.id
LEFT JOIN dat_cho dc ON dc.khoi_hanh_id = kh.id
LEFT JOIN danh_gia dg ON dg.tour_id = t.id AND dg.dang_hoat_dong = TRUE
WHERE ncc.id = $1
    AND ($2::timestamp IS NULL OR dc.ngay_dat >= $2)
    AND ($3::timestamp IS NULL OR dc.ngay_dat <= $3)
GROUP BY t.id, t.tieu_de, t.gia_nguoi_lon, t.gia_tre_em, t.don_vi_tien_te, t.trang_thai
ORDER BY 
    CASE WHEN $4::text = 'revenue' THEN COALESCE(SUM(dc.tong_tien) FILTER (WHERE dc.trang_thai IN ('da_thanh_toan', 'hoan_thanh')), 0) END DESC,
    CASE WHEN $4::text = 'bookings' THEN COUNT(DISTINCT dc.id) END DESC,
    CASE WHEN $4::text = 'rating' THEN COALESCE(AVG(dg.diem_danh_gia), 0) END DESC,
    total_bookings DESC
LIMIT $5
`

type GetSupplierTopToursParams struct {
	ID      pgtype.UUID      `json:"id"`
	Column2 pgtype.Timestamp `json:"column_2"`
	Column3 pgtype.Timestamp `json:"column_3"`
	Column4 string           `json:"column_4"`
	Limit   int32            `json:"limit"`
}

type GetSupplierTopToursRow struct {
	ID              int32          `json:"id"`
	TieuDe          string         `json:"tieu_de"`
	GiaNguoiLon     pgtype.Numeric `json:"gia_nguoi_lon"`
	GiaTreEm        pgtype.Numeric `json:"gia_tre_em"`
	DonViTienTe     *string        `json:"don_vi_tien_te"`
	TrangThai       *string        `json:"trang_thai"`
	AnhChinh        string         `json:"anh_chinh"`
	TotalBookings   int32          `json:"total_bookings"`
	TotalRevenue    pgtype.Numeric `json:"total_revenue"`
	TotalPassengers int32          `json:"total_passengers"`
	AvgRating       float64        `json:"avg_rating"`
	TotalReviews    int32          `json:"total_reviews"`
}

// Top tours bán chạy nhất theo số lượng booking và doanh thu
func (q *Queries) GetSupplierTopTours(ctx context.Context, arg GetSupplierTopToursParams) ([]GetSupplierTopToursRow, error) {
	rows, err := q.db.Query(ctx, getSupplierTopTours,
		arg.ID,
		arg.Column2,
		arg.Column3,
		arg.Column4,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetSupplierTopToursRow
	for rows.Next() {
		var i GetSupplierTopToursRow
		if err := rows.Scan(
			&i.ID,
			&i.TieuDe,
			&i.GiaNguoiLon,
			&i.GiaTreEm,
			&i.DonViTienTe,
			&i.TrangThai,
			&i.AnhChinh,
			&i.TotalBookings,
			&i.TotalRevenue,
			&i.TotalPassengers,
			&i.AvgRating,
			&i.TotalReviews,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSupplierTourStatsByStatus = `-- name: GetSupplierTourStatsByStatus :many
SELECT 
    t.trang_thai,
    COUNT(DISTINCT t.id)::int AS tour_count,
    COUNT(DISTINCT kh.id)::int AS total_departures,
    COUNT(DISTINCT dc.id)::int AS total_bookings,
    COALESCE(SUM(dc.tong_tien) FILTER (WHERE dc.trang_thai IN ('da_thanh_toan', 'hoan_thanh')), 0)::numeric AS total_revenue
FROM nha_cung_cap ncc
JOIN tour t ON t.nha_cung_cap_id = ncc.id AND t.dang_hoat_dong = TRUE
LEFT JOIN khoi_hanh_tour kh ON kh.tour_id = t.id
LEFT JOIN dat_cho dc ON dc.khoi_hanh_id = kh.id
WHERE ncc.id = $1
GROUP BY t.trang_thai
ORDER BY tour_count DESC
`

type GetSupplierTourStatsByStatusRow struct {
	TrangThai       *string        `json:"trang_thai"`
	TourCount       int32          `json:"tour_count"`
	TotalDepartures int32          `json:"total_departures"`
	TotalBookings   int32          `json:"total_bookings"`
	TotalRevenue    pgtype.Numeric `json:"total_revenue"`
}

// Thống kê tour theo trạng thái
func (q *Queries) GetSupplierTourStatsByStatus(ctx context.Context, id pgtype.UUID) ([]GetSupplierTourStatsByStatusRow, error) {
	rows, err := q.db.Query(ctx, getSupplierTourStatsByStatus, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetSupplierTourStatsByStatusRow
	for rows.Next() {
		var i GetSupplierTourStatsByStatusRow
		if err := rows.Scan(
			&i.TrangThai,
			&i.TourCount,
			&i.TotalDepartures,
			&i.TotalBookings,
			&i.TotalRevenue,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSupplierUpcomingDepartures = `-- name: GetSupplierUpcomingDepartures :many
SELECT 
    kh.id AS departure_id,
    kh.ngay_khoi_hanh,
    kh.ngay_ket_thuc,
    kh.suc_chua,
    kh.so_cho_da_dat,
    (kh.suc_chua - kh.so_cho_da_dat) AS available_seats,
    kh.trang_thai,
    t.id AS tour_id,
    t.tieu_de AS tour_title,
    (
        SELECT a.duong_dan
        FROM anh_tour a
        WHERE a.tour_id = t.id AND a.la_anh_chinh = TRUE
        LIMIT 1
    ) AS tour_image,
    COUNT(DISTINCT dc.id)::int AS booking_count,
    COALESCE(SUM(dc.tong_tien) FILTER (WHERE dc.trang_thai IN ('da_thanh_toan', 'hoan_thanh')), 0)::numeric AS revenue
FROM nha_cung_cap ncc
JOIN tour t ON t.nha_cung_cap_id = ncc.id AND t.dang_hoat_dong = TRUE
JOIN khoi_hanh_tour kh ON kh.tour_id = t.id
LEFT JOIN dat_cho dc ON dc.khoi_hanh_id = kh.id
WHERE ncc.id = $1
    AND kh.ngay_khoi_hanh >= CURRENT_DATE
    AND kh.trang_thai IN ('len_lich', 'xac_nhan', 'con_cho')
GROUP BY kh.id, kh.ngay_khoi_hanh, kh.ngay_ket_thuc, kh.suc_chua, kh.so_cho_da_dat, kh.trang_thai, t.id, t.tieu_de
ORDER BY kh.ngay_khoi_hanh ASC
LIMIT $2
`

type GetSupplierUpcomingDeparturesParams struct {
	ID    pgtype.UUID `json:"id"`
	Limit int32       `json:"limit"`
}

type GetSupplierUpcomingDeparturesRow struct {
	DepartureID    int32                 `json:"departure_id"`
	NgayKhoiHanh   pgtype.Date           `json:"ngay_khoi_hanh"`
	NgayKetThuc    pgtype.Date           `json:"ngay_ket_thuc"`
	SucChua        int32                 `json:"suc_chua"`
	SoChoDaDat     *int32                `json:"so_cho_da_dat"`
	AvailableSeats int32                 `json:"available_seats"`
	TrangThai      NullTrangThaiKhoiHanh `json:"trang_thai"`
	TourID         int32                 `json:"tour_id"`
	TourTitle      string                `json:"tour_title"`
	TourImage      string                `json:"tour_image"`
	BookingCount   int32                 `json:"booking_count"`
	Revenue        pgtype.Numeric        `json:"revenue"`
}

// Lịch khởi hành sắp tới
func (q *Queries) GetSupplierUpcomingDepartures(ctx context.Context, arg GetSupplierUpcomingDeparturesParams) ([]GetSupplierUpcomingDeparturesRow, error) {
	rows, err := q.db.Query(ctx, getSupplierUpcomingDepartures, arg.ID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetSupplierUpcomingDeparturesRow
	for rows.Next() {
		var i GetSupplierUpcomingDeparturesRow
		if err := rows.Scan(
			&i.DepartureID,
			&i.NgayKhoiHanh,
			&i.NgayKetThuc,
			&i.SucChua,
			&i.SoChoDaDat,
			&i.AvailableSeats,
			&i.TrangThai,
			&i.TourID,
			&i.TourTitle,
			&i.TourImage,
			&i.BookingCount,
			&i.Revenue,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSupplierWithTourCount = `-- name: GetSupplierWithTourCount :many
SELECT
    ncc.id, ncc.ten, ncc.dia_chi, ncc.website, ncc.mo_ta, ncc.logo, ncc.nam_thanh_lap, ncc.thanh_pho, ncc.quoc_gia, ncc.ma_so_thue, ncc.so_nhan_vien, ncc.giay_to_kinh_doanh,
    COUNT(t.id)::int AS total_tours,
    COUNT(CASE WHEN t.dang_hoat_dong = TRUE THEN 1 END)::int AS active_tours
FROM nha_cung_cap ncc
JOIN nguoi_dung ON nguoi_dung.id = nha_cung_cap.id
LEFT JOIN tour t ON t.nha_cung_cap_id = ncc.id
WHERE nguoi_dung.dang_hoat_dong = TRUE AND nguoi_dung.email = $1
GROUP BY ncc.id
ORDER BY total_tours DESC
`

type GetSupplierWithTourCountRow struct {
	ID              pgtype.UUID `json:"id"`
	Ten             string      `json:"ten"`
	DiaChi          *string     `json:"dia_chi"`
	Website         *string     `json:"website"`
	MoTa            *string     `json:"mo_ta"`
	Logo            *string     `json:"logo"`
	NamThanhLap     pgtype.Date `json:"nam_thanh_lap"`
	ThanhPho        *string     `json:"thanh_pho"`
	QuocGia         *string     `json:"quoc_gia"`
	MaSoThue        *string     `json:"ma_so_thue"`
	SoNhanVien      *string     `json:"so_nhan_vien"`
	GiayToKinhDoanh *string     `json:"giay_to_kinh_doanh"`
	TotalTours      int32       `json:"total_tours"`
	ActiveTours     int32       `json:"active_tours"`
}

func (q *Queries) GetSupplierWithTourCount(ctx context.Context, email string) ([]GetSupplierWithTourCountRow, error) {
	rows, err := q.db.Query(ctx, getSupplierWithTourCount, email)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetSupplierWithTourCountRow
	for rows.Next() {
		var i GetSupplierWithTourCountRow
		if err := rows.Scan(
			&i.ID,
			&i.Ten,
			&i.DiaChi,
			&i.Website,
			&i.MoTa,
			&i.Logo,
			&i.NamThanhLap,
			&i.ThanhPho,
			&i.QuocGia,
			&i.MaSoThue,
			&i.SoNhanVien,
			&i.GiayToKinhDoanh,
			&i.TotalTours,
			&i.ActiveTours,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSuppliersByStatus = `-- name: GetSuppliersByStatus :many
SELECT nha_cung_cap.id, ten, dia_chi, website, mo_ta, logo, nam_thanh_lap, thanh_pho, quoc_gia, ma_so_thue, so_nhan_vien, giay_to_kinh_doanh, nguoi_dung.id, ho_ten, email, mat_khau_ma_hoa, so_dien_thoai, vai_tro, dang_hoat_dong, xac_thuc, ngay_tao, ngay_cap_nhat FROM nha_cung_cap
JOIN nguoi_dung ON nguoi_dung.id = nha_cung_cap.id
WHERE nguoi_dung.dang_hoat_dong = TRUE
ORDER BY nguoi_dung.ngay_tao DESC
`

type GetSuppliersByStatusRow struct {
	ID              pgtype.UUID         `json:"id"`
	Ten             string              `json:"ten"`
	DiaChi          *string             `json:"dia_chi"`
	Website         *string             `json:"website"`
	MoTa            *string             `json:"mo_ta"`
	Logo            *string             `json:"logo"`
	NamThanhLap     pgtype.Date         `json:"nam_thanh_lap"`
	ThanhPho        *string             `json:"thanh_pho"`
	QuocGia         *string             `json:"quoc_gia"`
	MaSoThue        *string             `json:"ma_so_thue"`
	SoNhanVien      *string             `json:"so_nhan_vien"`
	GiayToKinhDoanh *string             `json:"giay_to_kinh_doanh"`
	ID_2            pgtype.UUID         `json:"id_2"`
	HoTen           string              `json:"ho_ten"`
	Email           string              `json:"email"`
	MatKhauMaHoa    string              `json:"mat_khau_ma_hoa"`
	SoDienThoai     *string             `json:"so_dien_thoai"`
	VaiTro          NullVaiTroNguoiDung `json:"vai_tro"`
	DangHoatDong    *bool               `json:"dang_hoat_dong"`
	XacThuc         *bool               `json:"xac_thuc"`
	NgayTao         pgtype.Timestamp    `json:"ngay_tao"`
	NgayCapNhat     pgtype.Timestamp    `json:"ngay_cap_nhat"`
}

func (q *Queries) GetSuppliersByStatus(ctx context.Context) ([]GetSuppliersByStatusRow, error) {
	rows, err := q.db.Query(ctx, getSuppliersByStatus)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetSuppliersByStatusRow
	for rows.Next() {
		var i GetSuppliersByStatusRow
		if err := rows.Scan(
			&i.ID,
			&i.Ten,
			&i.DiaChi,
			&i.Website,
			&i.MoTa,
			&i.Logo,
			&i.NamThanhLap,
			&i.ThanhPho,
			&i.QuocGia,
			&i.MaSoThue,
			&i.SoNhanVien,
			&i.GiayToKinhDoanh,
			&i.ID_2,
			&i.HoTen,
			&i.Email,
			&i.MatKhauMaHoa,
			&i.SoDienThoai,
			&i.VaiTro,
			&i.DangHoatDong,
			&i.XacThuc,
			&i.NgayTao,
			&i.NgayCapNhat,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const rejectSupplier = `-- name: RejectSupplier :one
UPDATE nguoi_dung
SET 
    dang_hoat_dong = FALSE,
    xac_thuc = FALSE,
    ngay_cap_nhat = CURRENT_TIMESTAMP
WHERE id = $1 
    AND vai_tro = 'nha_cung_cap'
RETURNING id, ho_ten, email, mat_khau_ma_hoa, so_dien_thoai, vai_tro, dang_hoat_dong, xac_thuc, ngay_tao, ngay_cap_nhat
`

// từ chối nhà cung cấp
func (q *Queries) RejectSupplier(ctx context.Context, id pgtype.UUID) (NguoiDung, error) {
	row := q.db.QueryRow(ctx, rejectSupplier, id)
	var i NguoiDung
	err := row.Scan(
		&i.ID,
		&i.HoTen,
		&i.Email,
		&i.MatKhauMaHoa,
		&i.SoDienThoai,
		&i.VaiTro,
		&i.DangHoatDong,
		&i.XacThuc,
		&i.NgayTao,
		&i.NgayCapNhat,
	)
	return i, err
}

const restoreSupplier = `-- name: RestoreSupplier :one
UPDATE nha_cung_cap
SET
    nha_cung_cap.dang_hoat_dong = TRUE,
    nha_cung_cap.ngay_cap_nhat = CURRENT_TIMESTAMP
WHERE id = $1
RETURNING id, ten, dia_chi, website, mo_ta, logo, nam_thanh_lap, thanh_pho, quoc_gia, ma_so_thue, so_nhan_vien, giay_to_kinh_doanh
`

func (q *Queries) RestoreSupplier(ctx context.Context, id pgtype.UUID) (NhaCungCap, error) {
	row := q.db.QueryRow(ctx, restoreSupplier, id)
	var i NhaCungCap
	err := row.Scan(
		&i.ID,
		&i.Ten,
		&i.DiaChi,
		&i.Website,
		&i.MoTa,
		&i.Logo,
		&i.NamThanhLap,
		&i.ThanhPho,
		&i.QuocGia,
		&i.MaSoThue,
		&i.SoNhanVien,
		&i.GiayToKinhDoanh,
	)
	return i, err
}

const searchSuppliers = `-- name: SearchSuppliers :many
SELECT nha_cung_cap.id, ten, dia_chi, website, mo_ta, logo, nam_thanh_lap, thanh_pho, quoc_gia, ma_so_thue, so_nhan_vien, giay_to_kinh_doanh, nguoi_dung.id, ho_ten, email, mat_khau_ma_hoa, so_dien_thoai, vai_tro, dang_hoat_dong, xac_thuc, ngay_tao, ngay_cap_nhat FROM nha_cung_cap
JOIN nguoi_dung ON nguoi_dung.id = nha_cung_cap.id
WHERE nguoi_dung.dang_hoat_dong = TRUE AND nguoi_dung.email = $1
    AND (
        ten ILIKE '%' || $1 || '%'
        OR email ILIKE '%' || $1 || '%'
        OR nguoi_dai_dien ILIKE '%' || $1 || '%'
        OR dia_chi ILIKE '%' || $1 || '%'
    )
ORDER BY ngay_tao DESC
`

type SearchSuppliersRow struct {
	ID              pgtype.UUID         `json:"id"`
	Ten             string              `json:"ten"`
	DiaChi          *string             `json:"dia_chi"`
	Website         *string             `json:"website"`
	MoTa            *string             `json:"mo_ta"`
	Logo            *string             `json:"logo"`
	NamThanhLap     pgtype.Date         `json:"nam_thanh_lap"`
	ThanhPho        *string             `json:"thanh_pho"`
	QuocGia         *string             `json:"quoc_gia"`
	MaSoThue        *string             `json:"ma_so_thue"`
	SoNhanVien      *string             `json:"so_nhan_vien"`
	GiayToKinhDoanh *string             `json:"giay_to_kinh_doanh"`
	ID_2            pgtype.UUID         `json:"id_2"`
	HoTen           string              `json:"ho_ten"`
	Email           string              `json:"email"`
	MatKhauMaHoa    string              `json:"mat_khau_ma_hoa"`
	SoDienThoai     *string             `json:"so_dien_thoai"`
	VaiTro          NullVaiTroNguoiDung `json:"vai_tro"`
	DangHoatDong    *bool               `json:"dang_hoat_dong"`
	XacThuc         *bool               `json:"xac_thuc"`
	NgayTao         pgtype.Timestamp    `json:"ngay_tao"`
	NgayCapNhat     pgtype.Timestamp    `json:"ngay_cap_nhat"`
}

func (q *Queries) SearchSuppliers(ctx context.Context, email string) ([]SearchSuppliersRow, error) {
	rows, err := q.db.Query(ctx, searchSuppliers, email)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SearchSuppliersRow
	for rows.Next() {
		var i SearchSuppliersRow
		if err := rows.Scan(
			&i.ID,
			&i.Ten,
			&i.DiaChi,
			&i.Website,
			&i.MoTa,
			&i.Logo,
			&i.NamThanhLap,
			&i.ThanhPho,
			&i.QuocGia,
			&i.MaSoThue,
			&i.SoNhanVien,
			&i.GiayToKinhDoanh,
			&i.ID_2,
			&i.HoTen,
			&i.Email,
			&i.MatKhauMaHoa,
			&i.SoDienThoai,
			&i.VaiTro,
			&i.DangHoatDong,
			&i.XacThuc,
			&i.NgayTao,
			&i.NgayCapNhat,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const softDeleteSupplier = `-- name: SoftDeleteSupplier :exec
UPDATE nha_cung_cap
SET
    nha_cung_cap.dang_hoat_dong = FALSE,
    nha_cung_cap.ngay_cap_nhat = CURRENT_TIMESTAMP
WHERE id = $1
`

func (q *Queries) SoftDeleteSupplier(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, softDeleteSupplier, id)
	return err
}

const updateSupplier = `-- name: UpdateSupplier :one
UPDATE nha_cung_cap
SET
    ten = COALESCE($2, nha_cung_cap.ten),
    dia_chi = COALESCE($3, nha_cung_cap.dia_chi),
    website = COALESCE($4, nha_cung_cap.website),
    mo_ta = COALESCE($5, nha_cung_cap.mo_ta),
    logo = COALESCE($6, nha_cung_cap.logo),
    ngay_cap_nhat = CURRENT_TIMESTAMP
WHERE id = $1 AND nguoi_dung.dang_hoat_dong = TRUE
RETURNING id, ten, dia_chi, website, mo_ta, logo, nam_thanh_lap, thanh_pho, quoc_gia, ma_so_thue, so_nhan_vien, giay_to_kinh_doanh
`

type UpdateSupplierParams struct {
	ID      pgtype.UUID `json:"id"`
	Ten     *string     `json:"ten"`
	DiaChi  *string     `json:"dia_chi"`
	Website *string     `json:"website"`
	MoTa    *string     `json:"mo_ta"`
	Logo    *string     `json:"logo"`
}

func (q *Queries) UpdateSupplier(ctx context.Context, arg UpdateSupplierParams) (NhaCungCap, error) {
	row := q.db.QueryRow(ctx, updateSupplier,
		arg.ID,
		arg.Ten,
		arg.DiaChi,
		arg.Website,
		arg.MoTa,
		arg.Logo,
	)
	var i NhaCungCap
	err := row.Scan(
		&i.ID,
		&i.Ten,
		&i.DiaChi,
		&i.Website,
		&i.MoTa,
		&i.Logo,
		&i.NamThanhLap,
		&i.ThanhPho,
		&i.QuocGia,
		&i.MaSoThue,
		&i.SoNhanVien,
		&i.GiayToKinhDoanh,
	)
	return i, err
}

const updateSupplierAndUser = `-- name: UpdateSupplierAndUser :one
BEGIN
`

type UpdateSupplierAndUserRow struct {
}

func (q *Queries) UpdateSupplierAndUser(ctx context.Context) (UpdateSupplierAndUserRow, error) {
	row := q.db.QueryRow(ctx, updateSupplierAndUser)
	var i UpdateSupplierAndUserRow
	err := row.Scan()
	return i, err
}

const updateSupplierStatus = `-- name: UpdateSupplierStatus :one
UPDATE nha_cung_cap
SET
    ngay_cap_nhat = CURRENT_TIMESTAMP
WHERE id = $1 AND nha_cung_cap.dang_hoat_dong = TRUE
RETURNING id, ten, dia_chi, website, mo_ta, logo, nam_thanh_lap, thanh_pho, quoc_gia, ma_so_thue, so_nhan_vien, giay_to_kinh_doanh
`

func (q *Queries) UpdateSupplierStatus(ctx context.Context, id pgtype.UUID) (NhaCungCap, error) {
	row := q.db.QueryRow(ctx, updateSupplierStatus, id)
	var i NhaCungCap
	err := row.Scan(
		&i.ID,
		&i.Ten,
		&i.DiaChi,
		&i.Website,
		&i.MoTa,
		&i.Logo,
		&i.NamThanhLap,
		&i.ThanhPho,
		&i.QuocGia,
		&i.MaSoThue,
		&i.SoNhanVien,
		&i.GiayToKinhDoanh,
	)
	return i, err
}

const updateTourStatus = `-- name: UpdateTourStatus :one
UPDATE tour
SET
    trang_thai = $2,
    ngay_cap_nhat = CURRENT_TIMESTAMP
WHERE id = $1 AND dang_hoat_dong = TRUE
RETURNING id, tieu_de, mo_ta, danh_muc_id, so_ngay, so_dem, gia_nguoi_lon, gia_tre_em, don_vi_tien_te, trang_thai, noi_bat, nha_cung_cap_id, dang_hoat_dong, ngay_tao, ngay_cap_nhat
`

type UpdateTourStatusParams struct {
	ID        int32   `json:"id"`
	TrangThai *string `json:"trang_thai"`
}

func (q *Queries) UpdateTourStatus(ctx context.Context, arg UpdateTourStatusParams) (Tour, error) {
	row := q.db.QueryRow(ctx, updateTourStatus, arg.ID, arg.TrangThai)
	var i Tour
	err := row.Scan(
		&i.ID,
		&i.TieuDe,
		&i.MoTa,
		&i.DanhMucID,
		&i.SoNgay,
		&i.SoDem,
		&i.GiaNguoiLon,
		&i.GiaTreEm,
		&i.DonViTienTe,
		&i.TrangThai,
		&i.NoiBat,
		&i.NhaCungCapID,
		&i.DangHoatDong,
		&i.NgayTao,
		&i.NgayCapNhat,
	)
	return i, err
}
